//go:build ignore
// +build ignore

// Command gen_perfect_hash_compressed builds compressed perfect hash lookup tables
// for 7-card evaluation using 24-bit packed HandRank values and writes them to
// ph_tables_compressed.go.
//
// This reduces memory usage by ~25% compared to the standard 32-bit implementation
// while maintaining O(1) lookup performance with minimal unpacking overhead.
//
// Invoke via: go generate -tags=compressed
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"log"
	"os"

	"github.com/lox/pokerforbots/internal/deck"
	"github.com/lox/pokerforbots/internal/evaluator"
	"github.com/opencoff/go-chd"
)

var primeRank = [...]int{
	0, 0, // 0,1 unused
	2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,
}

// packHandRank packs a 32-bit HandRank into 24 bits for compression
func packHandRank(hr evaluator.HandRank) [3]byte {
	val := uint32(hr)
	handType := (val >> 20) & 0xF // Extract 4-bit hand type
	tiebreaker := val & 0xFFFFF   // Extract 20-bit tiebreaker

	// Pack into 24 bits: [4-bit type][20-bit tiebreaker]
	packed := (handType << 20) | tiebreaker

	return [3]byte{
		byte(packed),       // Lower 8 bits
		byte(packed >> 8),  // Middle 8 bits
		byte(packed >> 16), // Upper 8 bits (includes type)
	}
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func main() {
	// Build full 52-card deck
	var deck52 [52]deck.Card
	idx := 0
	for s := 0; s < 4; s++ {
		for r := 2; r <= 14; r++ {
			deck52[idx] = deck.NewCard(s, r)
			idx++
		}
	}

	flushTable := make(map[int]evaluator.HandRank, 1000000)
	unsuitedTable := make(map[int]evaluator.HandRank, 5000000)

	var cards [7]deck.Card
	var comb func(int, int, int)
	comb = func(start, depth, k int) {
		if depth == k {
			rank := evaluator.Evaluate7Legacy(cards[:])

			// Accumulate suit counts and rank bitmap/product
			var suitCounts [4]int
			rb := 0
			prod := 1
			for _, c := range cards {
				suitCounts[c.Suit]++
				rb |= 1 << (c.Rank - 2)
				prod *= primeRank[c.Rank]
			}

			// detect flush
			flush := -1
			for s, cnt := range suitCounts {
				if cnt >= 5 {
					flush = s
					break
				}
			}
			if flush != -1 {
				// rebuild bitmap for flush suit
				frb := 0
				for _, c := range cards {
					if c.Suit == flush {
						frb |= 1 << (c.Rank - 2)
					}
				}
				flushTable[frb] = rank
			} else {
				unsuitedTable[prod] = rank
			}
			return
		}
		for i := start; i <= 52-(k-depth); i++ {
			cards[depth] = deck52[i]
			comb(i+1, depth+1, k)
		}
	}

	log.Println("Enumerating 7-card combinations (this will take a while)â€¦")
	comb(0, 0, 7)

	// Write compressed tables
	f, err := os.Create("ph_tables_compressed.go")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	w := bufio.NewWriter(f)
	fmt.Fprintln(w, "// Code generated by gen_perfect_hash_compressed.go; DO NOT EDIT.")
	fmt.Fprintln(w, "package evaluator\n")

	// Find maximum flush key to size slice
	maxFlushKey := 0
	for k := range flushTable {
		if k > maxFlushKey {
			maxFlushKey = k
		}
	}

	fmt.Fprintln(w, "func init() {")
	fmt.Fprintf(w, "    // Compressed flush table using 24-bit packed values\n")
	fmt.Fprintf(w, "    flushTableCompressed = [][3]byte{\n")

	originalFlushSize := 0
	compressedFlushSize := 0

	for i := 0; i <= maxFlushKey; i++ {
		originalFlushSize += 4   // 32-bit values
		compressedFlushSize += 3 // 24-bit values

		if v, ok := flushTable[i]; ok {
			packed := packHandRank(v)
			fmt.Fprintf(w, "        {0x%02x, 0x%02x, 0x%02x}, // %d -> %d\n", packed[0], packed[1], packed[2], i, v)
		} else {
			fmt.Fprintln(w, "        {0x00, 0x00, 0x00},")
		}
	}
	fmt.Fprintln(w, "    }\n")

	// Build CHD minimal perfect hash for unsuited hands
	log.Println("Building compressed CHD minimal perfect hash...")

	// Extract keys and build CHD
	unsKeys := make([]uint64, 0, len(unsuitedTable))
	for k := range unsuitedTable {
		unsKeys = append(unsKeys, uint64(k))
	}

	// Build CHD with optimal load factor
	builder, err := chd.New()
	if err != nil {
		log.Fatalf("Failed to create CHD builder: %v", err)
	}

	for _, key := range unsKeys {
		builder.Add(key)
	}

	mph, err := builder.Freeze(0.90) // High load factor for space efficiency
	if err != nil {
		log.Fatalf("Failed to build CHD: %v", err)
	}

	// Find the maximum index
	maxIndex := uint64(0)
	for _, key := range unsKeys {
		mphIndex := mph.Find(key)
		if mphIndex > maxIndex {
			maxIndex = mphIndex
		}
	}

	log.Printf("Compressed CHD: %d keys, max index: %d", len(unsKeys), maxIndex)

	// Create compressed value array
	unsuitedValuesCompressed := make([][3]byte, maxIndex+1)

	// Track which indices are used to detect collisions
	usedIndices := make(map[uint64]bool)

	for _, key := range unsKeys {
		intKey := int(key)
		mphIndex := mph.Find(key)

		if usedIndices[mphIndex] {
			log.Fatalf("Compressed CHD collision: index %d used by multiple keys", mphIndex)
		}
		usedIndices[mphIndex] = true

		// Pack the HandRank value
		originalRank := unsuitedTable[intKey]
		packed := packHandRank(originalRank)
		unsuitedValuesCompressed[mphIndex] = packed
	}

	// Validate the compressed CHD mapping
	log.Printf("Validating compressed CHD mapping...")
	for i, key := range unsKeys[:min(10, len(unsKeys))] {
		intKey := int(key)
		mphIndex := mph.Find(key)
		originalRank := unsuitedTable[intKey]

		// Unpack and verify
		packed := unsuitedValuesCompressed[mphIndex]
		unpackedVal := uint32(packed[0]) | (uint32(packed[1]) << 8) | (uint32(packed[2]) << 16)
		unpackedRank := evaluator.HandRank(unpackedVal)

		if originalRank != unpackedRank {
			log.Fatalf("Compressed CHD validation failed for key %d: original=%d, unpacked=%d", intKey, originalRank, unpackedRank)
		}
		if i < 3 {
			log.Printf("Compressed CHD validation OK: key=%d -> index=%d -> rank=%d", intKey, mphIndex, unpackedRank)
		}
	}
	log.Printf("Compressed CHD validation passed")

	// Serialize CHD for code generation (same as original)
	var chdBuffer bytes.Buffer
	_, err = mph.MarshalBinary(&chdBuffer)
	if err != nil {
		log.Fatalf("Failed to serialize compressed CHD: %v", err)
	}
	chdBytes := chdBuffer.Bytes()

	// Emit compressed CHD tables
	fmt.Fprintf(w, "    // Compressed CHD minimal perfect hash tables (targeting 6-7ns lookups)\n")
	fmt.Fprintf(w, "    unsuitedCHDDataCompressed = []byte{\n")
	for i, b := range chdBytes {
		if i%16 == 0 {
			fmt.Fprintf(w, "        ")
		}
		fmt.Fprintf(w, "0x%02x, ", b)
		if i%16 == 15 {
			fmt.Fprintf(w, "\n")
		}
	}
	if len(chdBytes)%16 != 0 {
		fmt.Fprintf(w, "\n")
	}
	fmt.Fprintf(w, "    }\n\n")

	// Emit compressed unsuited values
	fmt.Fprintf(w, "    // Compressed unsuited values using 24-bit packing\n")
	fmt.Fprintf(w, "    unsuitedValuesCompressed = [][3]byte{\n")

	originalUnsuitedSize := len(unsuitedValuesCompressed) * 4   // 32-bit values
	compressedUnsuitedSize := len(unsuitedValuesCompressed) * 3 // 24-bit values

	for i, packed := range unsuitedValuesCompressed {
		if i%8 == 0 {
			fmt.Fprintf(w, "        ")
		}
		fmt.Fprintf(w, "{0x%02x, 0x%02x, 0x%02x}, ", packed[0], packed[1], packed[2])
		if i%8 == 7 {
			fmt.Fprintf(w, "\n")
		}
	}
	if len(unsuitedValuesCompressed)%8 != 0 {
		fmt.Fprintf(w, "\n")
	}
	fmt.Fprintf(w, "    }\n\n")

	fmt.Fprintln(w, "    compressedHashReady = true\n}")

	if err := w.Flush(); err != nil {
		log.Fatal(err)
	}

	// Calculate and report memory savings
	totalOriginal := originalFlushSize + originalUnsuitedSize + len(chdBytes)
	totalCompressed := compressedFlushSize + compressedUnsuitedSize + len(chdBytes)
	savedBytes := totalOriginal - totalCompressed
	savedPercent := float64(savedBytes) / float64(totalOriginal) * 100

	log.Printf("Generated ph_tables_compressed.go:")
	log.Printf("  Flush entries: %d (original: %d KB, compressed: %d KB)",
		len(flushTable), originalFlushSize/1024, compressedFlushSize/1024)
	log.Printf("  Unsuited entries: %d (original: %d KB, compressed: %d KB)",
		len(unsuitedTable), originalUnsuitedSize/1024, compressedUnsuitedSize/1024)
	log.Printf("  CHD data: %d KB (unchanged)", len(chdBytes)/1024)
	log.Printf("  Total memory: %d KB -> %d KB (%.1f%% reduction)",
		totalOriginal/1024, totalCompressed/1024, savedPercent)
}
