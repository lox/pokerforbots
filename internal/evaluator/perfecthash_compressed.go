package evaluator

// This file implements a compressed version of the CHD perfect hash evaluator
// that uses 24-bit packed HandRank values instead of 32-bit for better cache performance.
//
// The compression packs:
// - 4 bits: hand type (1-10)
// - 20 bits: tiebreaker data
// Total: 24 bits vs original 32 bits (25% memory reduction)

import (
	"fmt"
	"log"
	"sync"

	"github.com/lox/pokerforbots/internal/deck"
	"github.com/opencoff/go-chd"
)

// Prime numbers for ranks (2 through Ace)
var primeRank = [...]int{
	0, 0, // 0,1 unused
	2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,
}

// Compressed tables - generated by gen_perfect_hash_compressed.go
var flushTableCompressed [][3]byte     // 24-bit packed values
var unsuitedValuesCompressed [][3]byte // 24-bit packed values
var unsuitedCHDDataCompressed []byte   // Same CHD structure
var unsuitedCHDCompressed *chd.Chd     // Deserialized CHD for lookups

// compressedHashReady indicates whether compressed tables have been generated
var compressedHashReady bool

var chdCompressedInitOnce sync.Once

// packHandRank packs a 32-bit HandRank into 24 bits for table generation
// Format: [4-bit type][20-bit tiebreaker]
// This function is used by the generator but kept here for documentation
func packHandRank(hr HandRank) [3]byte { //nolint:unused // Used by generator
	val := uint32(hr)
	handType := (val >> 20) & 0xF // Extract 4-bit hand type
	tiebreaker := val & 0xFFFFF   // Extract 20-bit tiebreaker

	// Pack into 24 bits: [4-bit type][20-bit tiebreaker]
	packed := (handType << 20) | tiebreaker

	return [3]byte{
		byte(packed),       // Lower 8 bits
		byte(packed >> 8),  // Middle 8 bits
		byte(packed >> 16), // Upper 8 bits (includes type)
	}
}

// unpackHandRank unpacks a 24-bit value back to HandRank
//
//go:inline
func unpackHandRank(packed [3]byte) HandRank {
	// Reconstruct 24-bit value
	val := uint32(packed[0]) | (uint32(packed[1]) << 8) | (uint32(packed[2]) << 16)
	return HandRank(val)
}

// ensureCHDCompressedLoaded ensures compressed CHD is deserialized exactly once
func ensureCHDCompressedLoaded() {
	chdCompressedInitOnce.Do(func() {
		// Deserialize CHD if data is available
		if len(unsuitedCHDDataCompressed) > 0 && unsuitedCHDCompressed == nil {
			unsuitedCHDCompressed = &chd.Chd{}
			err := unsuitedCHDCompressed.UnmarshalBinaryMmap(unsuitedCHDDataCompressed)
			if err != nil {
				// Fall back to legacy evaluator if CHD fails to load
				log.Printf("Compressed CHD deserialization failed: %v", err)
				unsuitedCHDCompressed = nil
			}
		}

		compressedHashReady = len(flushTableCompressed) > 0 && (unsuitedCHDCompressed != nil && len(unsuitedValuesCompressed) > 0)
	})
}

// unsuitedLookupCHDCompressed performs minimal perfect hash lookup using compressed CHD.
// Target performance: 6-7ns (2 table reads, 1 multiply, unpack overhead)
//
//go:noinline
func unsuitedLookupCHDCompressed(primeProd uint64) HandRank {
	// CHD lookup: single function call, internally optimized
	index := unsuitedCHDCompressed.Find(primeProd)
	if index >= uint64(len(unsuitedValuesCompressed)) {
		// Index out of bounds - shouldn't happen with valid CHD
		log.Printf("Compressed CHD index out of bounds: %d >= %d for key %d", index, len(unsuitedValuesCompressed), primeProd)
		panic(fmt.Sprintf("CHD index out of bounds: %d >= %d for key %d", index, len(unsuitedValuesCompressed), primeProd))
	}

	// Unpack 24-bit value to HandRank
	packed := unsuitedValuesCompressed[index]
	result := unpackHandRank(packed)

	if result == 0 {
		// This should never happen with a working CHD for our key set
		panic(fmt.Sprintf("Compressed CHD returned zero value for key %d at index %d - regenerate tables", primeProd, index))
	}

	return result
}

// Evaluate7Compressed evaluates a 7-card hand using compressed CHD minimal perfect hash.
// This implementation targets 6-7ns for unsuited hands via compressed CHD lookup.
//
// Memory usage: ~250KB (25% reduction from 333KB baseline)
// - flushTableCompressed: ~10KB (vs 13.3KB)
// - unsuitedValuesCompressed: ~196KB (vs 256KB)
// - CHD structure: ~64KB (unchanged)
//
// Falls back to legacy evaluator when tables haven't been generated.
func Evaluate7Compressed(cards []deck.Card) HandRank {
	ensureCHDCompressedLoaded()

	if !compressedHashReady {
		// tables missing – fall back so that tests still run.
		return evaluate7Basic(cards)
	}

	var (
		rankBits   int // 13-bit bitmap of ranks present (2 = bit0, …, Ace = bit12)
		suitCounts [4]int
		primeProd  = uint64(1) // Use uint64 to prevent overflow
	)

	for _, c := range cards {
		suitCounts[c.Suit]++
		rankShift := c.Rank - 2 // 0-based shift
		rankBits |= 1 << rankShift
		primeProd *= uint64(primeRank[c.Rank])
	}

	// Check for flush
	flushSuit := -1
	for s, cnt := range suitCounts {
		if cnt >= 5 {
			flushSuit = s
			break
		}
	}

	if flushSuit != -1 {
		// Build rank bitmap for that suit only
		rb := 0
		for _, c := range cards {
			if c.Suit == flushSuit {
				rb |= 1 << (c.Rank - 2)
			}
		}
		if rb < len(flushTableCompressed) {
			packed := flushTableCompressed[rb]
			if packed != [3]byte{0, 0, 0} { // Check for non-zero packed value
				return unpackHandRank(packed)
			}
		}
	}

	return unsuitedLookupCHDCompressed(primeProd)
}
