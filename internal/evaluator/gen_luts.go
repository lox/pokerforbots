// +build ignore

// This program generates lookup tables for poker hand evaluation at compile time.
// Run with: go run gen_luts.go

package main

import (
	"fmt"
	"os"
)

func main() {
	f, err := os.Create("luts_generated.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Fprint(f, `// Code generated by go generate; DO NOT EDIT.
// This file contains pre-computed lookup tables for poker hand evaluation.

package evaluator

// Pre-computed Look-Up Tables generated at compile time for maximum performance
var (
	// straightLUT: for each 13-bit rank pattern, stores straight high card (0 = no straight)
	// Index: (rank bitmask >> 2) since ranks 2-14 map to bits 2-14
	// Size: 2^13 = 8192 bytes = 8KB (very cache-friendly)
	straightLUT = [8192]uint8{
`)

	// Generate straight LUT
	for rankBits := 0; rankBits < 8192; rankBits++ {
		// Convert back to full rank bitmap (shift left by 2 to account for ranks 2-14)
		fullBits := uint32(rankBits) << 2
		straightHigh := computeStraight(fullBits)
		
		if rankBits%16 == 0 {
			fmt.Fprintf(f, "\n\t\t")
		}
		fmt.Fprintf(f, "%d, ", straightHigh)
	}

	fmt.Fprint(f, `
	}

	// kickerLUT: for each rank availability pattern, stores highest single rank
	// Size: 2^15 = 32KB for all possible rank combinations
	kickerLUT = [32768]uint8{
`)

	// Generate kicker LUT
	for mask := 0; mask < 32768; mask++ {
		kickerValue := computeHighestSingle(mask)
		
		if mask%16 == 0 {
			fmt.Fprintf(f, "\n\t\t")
		}
		fmt.Fprintf(f, "%d, ", kickerValue)
	}

	fmt.Fprint(f, `
	}
)
`)

	fmt.Println("Generated luts_generated.go with compile-time lookup tables")
}

// computeStraight implements the original straight detection logic
func computeStraight(rankBits uint32) int {
	// Check for wheel straight (A-2-3-4-5)
	wheel := uint32(1<<14 | 1<<5 | 1<<4 | 1<<3 | 1<<2)
	if (rankBits & wheel) == wheel {
		return 5 // In wheel, 5 is high card
	}

	// Check for other straights (need 5 consecutive bits)
	for high := 14; high >= 6; high-- {
		mask := uint32(0x1F) << uint(high-4) // 5 consecutive bits
		if (rankBits & mask) == mask {
			return high
		}
	}
	return 0
}

// computeHighestSingle finds highest rank that has count=1 in the bitmask
func computeHighestSingle(mask int) int {
	for rank := 14; rank >= 2; rank-- {
		if (mask & (1 << rank)) != 0 {
			return rank
		}
	}
	return 0
}
