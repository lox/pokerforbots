//go:build ignore
// +build ignore

// Command gen_perfect_hash builds the perfect hash lookup tables for 7-card
// evaluation and writes them to ph_tables.go.  It is invoked via:
//
//	go generate
//
// Expect the process to take a couple of minutes and consume a few GB of RAM.
//
// The algorithm mirrors the classic C "7-card evaluator" generator: iterate over
// every 7-card combination, compute its HandRank via the legacy evaluator, then
// fill the suited/unsuited tables keyed by rank-bitmap or prime product.
//
// Because the resulting tables are large we marshal them as Go literal maps.  A
// future optimisation would compress them into slices with a two-stage perfect
// hash, but this simple approach is quite fast on contemporary machines.
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"log"
	"os"

	"github.com/lox/pokerforbots/internal/deck"
	"github.com/lox/pokerforbots/internal/evaluator"
	"github.com/opencoff/go-chd"
)

var primeRank = [...]int{
	0, 0, // 0,1 unused
	2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func main() {
	// Build full 52-card deck
	var deck52 [52]deck.Card
	idx := 0
	for s := 0; s < 4; s++ {
		for r := 2; r <= 14; r++ {
			deck52[idx] = deck.NewCard(s, r)
			idx++
		}
	}

	flushTable := make(map[int]evaluator.HandRank, 1000000)
	unsuitedTable := make(map[int]evaluator.HandRank, 5000000)

	var cards [7]deck.Card
	var comb func(int, int, int)
	comb = func(start, depth, k int) {
		if depth == k {
			rank := evaluator.Evaluate7Legacy(cards[:])

			// Accumulate suit counts and rank bitmap/product
			var suitCounts [4]int
			rb := 0
			prod := 1
			for _, c := range cards {
				suitCounts[c.Suit]++
				rb |= 1 << (c.Rank - 2)
				prod *= primeRank[c.Rank]
			}

			// detect flush
			flush := -1
			for s, cnt := range suitCounts {
				if cnt >= 5 {
					flush = s
					break
				}
			}
			if flush != -1 {
				// rebuild bitmap for flush suit
				frb := 0
				for _, c := range cards {
					if c.Suit == flush {
						frb |= 1 << (c.Rank - 2)
					}
				}
				flushTable[frb] = rank
			} else {
				unsuitedTable[prod] = rank
			}
			return
		}
		for i := start; i <= 52-(k-depth); i++ {
			cards[depth] = deck52[i]
			comb(i+1, depth+1, k)
		}
	}

	log.Println("Enumerating 7-card combinations (this will take a while)â€¦")
	comb(0, 0, 7)

	// Serialise to Go code
	// Write tables beside the generator inside the evaluator package so that
	// they compile into the same Go package regardless of where `go generate`
	// was invoked from.
	f, err := os.Create("ph_tables.go")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	w := bufio.NewWriter(f)
	fmt.Fprintln(w, "// Code generated by gen_perfect_hash.go; DO NOT EDIT.")
	fmt.Fprintln(w, "package evaluator\n")

	// Emit flushTable as a dense slice keyed by rank bitmap (max key fits in
	// 13 bits => 8192). We create a fixed-length literal so look-ups are O(1)
	// array indexing at runtime.

	// Find maximum flush key to size slice
	maxFlushKey := 0
	for k := range flushTable {
		if k > maxFlushKey {
			maxFlushKey = k
		}
	}

	fmt.Fprintln(w, "func init() {")
	fmt.Fprintf(w, "    flushTable = []HandRank{\n")
	for i := 0; i <= maxFlushKey; i++ {
		if v, ok := flushTable[i]; ok {
			fmt.Fprintf(w, "        %d, // %d\n", v, i)
		} else {
			fmt.Fprintln(w, "        0,")
		}
	}
	fmt.Fprintln(w, "    }\n")

	// Build CHD (Compress, Hash, Displace) minimal perfect hash
	// This replaces the map with ~150KB of tables targeting 5-6ns lookups
	log.Println("Building CHD minimal perfect hash...")

	// Extract keys and build CHD
	unsKeys := make([]uint64, 0, len(unsuitedTable))
	for k := range unsuitedTable {
		unsKeys = append(unsKeys, uint64(k))
	}

	// Build CHD with optimal load factor
	builder, err := chd.New()
	if err != nil {
		log.Fatalf("Failed to create CHD builder: %v", err)
	}

	for _, key := range unsKeys {
		builder.Add(key)
	}

	mph, err := builder.Freeze(0.90) // High load factor for space efficiency
	if err != nil {
		log.Fatalf("Failed to build CHD: %v", err)
	}

	// CHD might return indices up to some larger range, not just len(keys)
	// Let's find the maximum index first
	maxIndex := uint64(0)
	for _, key := range unsKeys {
		mphIndex := mph.Find(key)
		if mphIndex > maxIndex {
			maxIndex = mphIndex
		}
	}

	log.Printf("CHD: %d keys, max index: %d", len(unsKeys), maxIndex)

	// Create value array sized to accommodate max index
	unsuitedValues := make([]evaluator.HandRank, maxIndex+1)

	// Track which indices are used to detect collisions
	usedIndices := make(map[uint64]bool)

	for _, key := range unsKeys {
		intKey := int(key)
		mphIndex := mph.Find(key)

		if usedIndices[mphIndex] {
			log.Fatalf("CHD collision: index %d used by multiple keys", mphIndex)
		}
		usedIndices[mphIndex] = true

		unsuitedValues[mphIndex] = unsuitedTable[intKey]
	}

	// Validate the CHD mapping by checking a few random keys
	log.Printf("Validating CHD mapping...")
	for i, key := range unsKeys[:min(10, len(unsKeys))] {
		intKey := int(key)
		mphIndex := mph.Find(key)
		originalRank := unsuitedTable[intKey]
		chdRank := unsuitedValues[mphIndex]

		if originalRank != chdRank {
			log.Fatalf("CHD validation failed for key %d: original=%d, chd=%d", intKey, originalRank, chdRank)
		}
		if i < 3 {
			log.Printf("CHD validation OK: key=%d -> index=%d -> rank=%d", intKey, mphIndex, chdRank)
		}
	}
	log.Printf("CHD validation passed")

	// Serialize CHD for code generation
	var chdBuffer bytes.Buffer
	_, err = mph.MarshalBinary(&chdBuffer)
	if err != nil {
		log.Fatalf("Failed to serialize CHD: %v", err)
	}
	chdBytes := chdBuffer.Bytes()

	// Emit CHD tables
	fmt.Fprintf(w, "    // CHD minimal perfect hash tables (targeting 5-6ns lookups)\n")
	fmt.Fprintf(w, "    unsuitedCHDData = []byte{\n")
	for i, b := range chdBytes {
		if i%16 == 0 {
			fmt.Fprintf(w, "        ")
		}
		fmt.Fprintf(w, "0x%02x, ", b)
		if i%16 == 15 {
			fmt.Fprintf(w, "\n")
		}
	}
	if len(chdBytes)%16 != 0 {
		fmt.Fprintf(w, "\n")
	}
	fmt.Fprintf(w, "    }\n\n")

	fmt.Fprintf(w, "    unsuitedValues = []HandRank{\n")
	for i, v := range unsuitedValues {
		if i%8 == 0 {
			fmt.Fprintf(w, "        ")
		}
		fmt.Fprintf(w, "%d, ", v)
		if i%8 == 7 {
			fmt.Fprintf(w, "\n")
		}
	}
	if len(unsuitedValues)%8 != 0 {
		fmt.Fprintf(w, "\n")
	}
	fmt.Fprintf(w, "    }\n\n")

	fmt.Fprintln(w, "    perfectHashReady = true\n}")

	if err := w.Flush(); err != nil {
		log.Fatal(err)
	}

	log.Printf("Generated ph_tables.go with %d flush entries, %d unsuited CHD entries (~%d KB)",
		len(flushTable), len(unsuitedTable), len(chdBytes)/1024)
}
