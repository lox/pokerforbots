package evaluator

// This file implements a perfect-hash based 7-card evaluator.  It is a drop-in
// scalar translation of the widely used "Perfect Hash 7" algorithm (see
// https://web.archive.org/web/20110723024515/http://www.suffecool.net/poker/evaluator.html)
// but written in pure Go.
//
// A separate `go:generate` program (gen_perfect_hash.go) enumerates every
// 7-card combination (52 choose 7 ≃ 133 M) once, computes the best hand via the
// existing fallback evaluator and emits two lookup tables:
//   1. `flushTable`  – indexed by 13-bit rank bitmap when ≥5 cards of one suit
//   2. `unsuitedTable` – indexed by unique rank prime-product hash
// The generated tables live in ph_tables.go in this package.
//
// At runtime `Evaluate7Perfect` performs only three steps:
//   – accumulate suit counts + rank bitmap + prime product in a single loop
//   – if flush ⇒ return flushTable[rankBits]
//   – else      ⇒ return unsuitedTable[primeProduct]
// This removes all branches and dynamic allocation from the hot-path.

import (
	"github.com/lox/pokerforbots/internal/deck"
)

// primeRank holds the first 13 primes, mapped so that index == card.Rank.
// Index 0 and 1 are unused (ranks start at 2).
var primeRank = [...]int{
	0, 0, // 0,1 unused
	2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, // 2-14
}

// flushTable and unsuitedTable are generated by gen_perfect_hash.go.
// They map unique hand keys to the evaluator's ordinal HandRank (lower == stronger).
// The variables are declared here but initialized by the generated code.
var flushTable []HandRank
var unsuitedTable map[int]HandRank

// perfectHashReady indicates whether go:generate has produced the tables.
var perfectHashReady bool

func init() {
	perfectHashReady = len(flushTable) > 0 && len(unsuitedTable) > 0
}

// Evaluate7Perfect evaluates a 7-card hand using the perfect hash tables.
// This implementation uses Go's built-in map for optimal performance (~35ns).
//
// OPTIMIZATION NOTE: We tested several approaches during development:
// - Map-based lookup (current): ~35ns - Go's optimized hash tables win
// - Bucketed linear scan: ~58ns - Manual optimization overhead
// - Binary search arrays: ~105ns - Cache misses hurt performance
// See OPTIMIZATIONS.md for detailed analysis.
//
// Falls back to legacy evaluator when tables haven't been generated,
// allowing `go test` to succeed before `go generate` is run.
func Evaluate7Perfect(cards []deck.Card) HandRank {
	if !perfectHashReady {
		// tables missing – fall back so that tests still run.
		return Evaluate7Legacy(cards)
	}

	var (
		rankBits   int // 13-bit bitmap of ranks present (2 = bit0, …, Ace = bit12)
		suitCounts [4]int
		primeProd  = 1
	)

	for _, c := range cards {
		suitCounts[c.Suit]++
		rankShift := c.Rank - 2 // 0-based shift
		rankBits |= 1 << rankShift
		primeProd *= primeRank[c.Rank]
	}

	// Check for flush
	flushSuit := -1
	for s, cnt := range suitCounts {
		if cnt >= 5 {
			flushSuit = s
			break
		}
	}

	if flushSuit != -1 {
		// Build rank bitmap for that suit only
		rb := 0
		for _, c := range cards {
			if c.Suit == flushSuit {
				rb |= 1 << (c.Rank - 2)
			}
		}
		if rb < len(flushTable) {
			if v := flushTable[rb]; v != 0 {
				return v
			}
		}
	}

	if v, ok := unsuitedTable[primeProd]; ok {
		return v
	}

	// Should not happen with complete tables; fallback for safety.
	return Evaluate7Legacy(cards)
}

// Evaluate7Legacy is an alias for the existing evaluator implementation so that
// we can call it without circular references.
func Evaluate7Legacy(cards []deck.Card) HandRank {
	return evaluate7Basic(cards) // call original basic evaluator implementation
}
