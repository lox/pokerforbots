// Code generated by github.com/tinylib/msgp DO NOT EDIT.

package protocol

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Action) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "action":
			z.Action, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Action")
				return
			}
		case "amount":
			z.Amount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Amount")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Action) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "type"
	err = en.Append(0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "action"
	err = en.Append(0xa6, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Action)
	if err != nil {
		err = msgp.WrapError(err, "Action")
		return
	}
	// write "amount"
	err = en.Append(0xa6, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Amount)
	if err != nil {
		err = msgp.WrapError(err, "Amount")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Action) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "action"
	o = append(o, 0xa6, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Action)
	// string "amount"
	o = append(o, 0xa6, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.Amount)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Action) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "action":
			z.Action, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Action")
				return
			}
		case "amount":
			z.Amount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Amount")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Action) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 7 + msgp.StringPrefixSize + len(z.Action) + 7 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ActionRequest) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "hand_id":
			z.HandID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HandID")
				return
			}
		case "time_remaining":
			z.TimeRemaining, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "TimeRemaining")
				return
			}
		case "valid_actions":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ValidActions")
				return
			}
			if cap(z.ValidActions) >= int(zb0002) {
				z.ValidActions = (z.ValidActions)[:zb0002]
			} else {
				z.ValidActions = make([]string, zb0002)
			}
			for za0001 := range z.ValidActions {
				z.ValidActions[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ValidActions", za0001)
					return
				}
			}
		case "to_call":
			z.ToCall, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ToCall")
				return
			}
		case "min_bet":
			z.MinBet, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MinBet")
				return
			}
		case "min_raise":
			z.MinRaise, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MinRaise")
				return
			}
		case "pot":
			z.Pot, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Pot")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ActionRequest) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "type"
	err = en.Append(0x88, 0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "hand_id"
	err = en.Append(0xa7, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.HandID)
	if err != nil {
		err = msgp.WrapError(err, "HandID")
		return
	}
	// write "time_remaining"
	err = en.Append(0xae, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x72, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67)
	if err != nil {
		return
	}
	err = en.WriteInt(z.TimeRemaining)
	if err != nil {
		err = msgp.WrapError(err, "TimeRemaining")
		return
	}
	// write "valid_actions"
	err = en.Append(0xad, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ValidActions)))
	if err != nil {
		err = msgp.WrapError(err, "ValidActions")
		return
	}
	for za0001 := range z.ValidActions {
		err = en.WriteString(z.ValidActions[za0001])
		if err != nil {
			err = msgp.WrapError(err, "ValidActions", za0001)
			return
		}
	}
	// write "to_call"
	err = en.Append(0xa7, 0x74, 0x6f, 0x5f, 0x63, 0x61, 0x6c, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ToCall)
	if err != nil {
		err = msgp.WrapError(err, "ToCall")
		return
	}
	// write "min_bet"
	err = en.Append(0xa7, 0x6d, 0x69, 0x6e, 0x5f, 0x62, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MinBet)
	if err != nil {
		err = msgp.WrapError(err, "MinBet")
		return
	}
	// write "min_raise"
	err = en.Append(0xa9, 0x6d, 0x69, 0x6e, 0x5f, 0x72, 0x61, 0x69, 0x73, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MinRaise)
	if err != nil {
		err = msgp.WrapError(err, "MinRaise")
		return
	}
	// write "pot"
	err = en.Append(0xa3, 0x70, 0x6f, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Pot)
	if err != nil {
		err = msgp.WrapError(err, "Pot")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ActionRequest) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "type"
	o = append(o, 0x88, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "hand_id"
	o = append(o, 0xa7, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.HandID)
	// string "time_remaining"
	o = append(o, 0xae, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x72, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67)
	o = msgp.AppendInt(o, z.TimeRemaining)
	// string "valid_actions"
	o = append(o, 0xad, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ValidActions)))
	for za0001 := range z.ValidActions {
		o = msgp.AppendString(o, z.ValidActions[za0001])
	}
	// string "to_call"
	o = append(o, 0xa7, 0x74, 0x6f, 0x5f, 0x63, 0x61, 0x6c, 0x6c)
	o = msgp.AppendInt(o, z.ToCall)
	// string "min_bet"
	o = append(o, 0xa7, 0x6d, 0x69, 0x6e, 0x5f, 0x62, 0x65, 0x74)
	o = msgp.AppendInt(o, z.MinBet)
	// string "min_raise"
	o = append(o, 0xa9, 0x6d, 0x69, 0x6e, 0x5f, 0x72, 0x61, 0x69, 0x73, 0x65)
	o = msgp.AppendInt(o, z.MinRaise)
	// string "pot"
	o = append(o, 0xa3, 0x70, 0x6f, 0x74)
	o = msgp.AppendInt(o, z.Pot)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ActionRequest) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "hand_id":
			z.HandID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HandID")
				return
			}
		case "time_remaining":
			z.TimeRemaining, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TimeRemaining")
				return
			}
		case "valid_actions":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ValidActions")
				return
			}
			if cap(z.ValidActions) >= int(zb0002) {
				z.ValidActions = (z.ValidActions)[:zb0002]
			} else {
				z.ValidActions = make([]string, zb0002)
			}
			for za0001 := range z.ValidActions {
				z.ValidActions[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ValidActions", za0001)
					return
				}
			}
		case "to_call":
			z.ToCall, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ToCall")
				return
			}
		case "min_bet":
			z.MinBet, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinBet")
				return
			}
		case "min_raise":
			z.MinRaise, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinRaise")
				return
			}
		case "pot":
			z.Pot, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Pot")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ActionRequest) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 8 + msgp.StringPrefixSize + len(z.HandID) + 15 + msgp.IntSize + 14 + msgp.ArrayHeaderSize
	for za0001 := range z.ValidActions {
		s += msgp.StringPrefixSize + len(z.ValidActions[za0001])
	}
	s += 8 + msgp.IntSize + 8 + msgp.IntSize + 10 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Card) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = Card(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Card) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Card) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Card) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = Card(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Card) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CategoryStatSummary) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "hands":
			z.Hands, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Hands")
				return
			}
		case "net_bb":
			z.NetBB, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "NetBB")
				return
			}
		case "bb_per_hand":
			z.BBPerHand, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BBPerHand")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z CategoryStatSummary) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "hands"
	err = en.Append(0x83, 0xa5, 0x68, 0x61, 0x6e, 0x64, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Hands)
	if err != nil {
		err = msgp.WrapError(err, "Hands")
		return
	}
	// write "net_bb"
	err = en.Append(0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.NetBB)
	if err != nil {
		err = msgp.WrapError(err, "NetBB")
		return
	}
	// write "bb_per_hand"
	err = en.Append(0xab, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BBPerHand)
	if err != nil {
		err = msgp.WrapError(err, "BBPerHand")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CategoryStatSummary) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "hands"
	o = append(o, 0x83, 0xa5, 0x68, 0x61, 0x6e, 0x64, 0x73)
	o = msgp.AppendInt(o, z.Hands)
	// string "net_bb"
	o = append(o, 0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
	o = msgp.AppendFloat64(o, z.NetBB)
	// string "bb_per_hand"
	o = append(o, 0xab, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
	o = msgp.AppendFloat64(o, z.BBPerHand)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CategoryStatSummary) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "hands":
			z.Hands, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hands")
				return
			}
		case "net_bb":
			z.NetBB, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NetBB")
				return
			}
		case "bb_per_hand":
			z.BBPerHand, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BBPerHand")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CategoryStatSummary) Msgsize() (s int) {
	s = 1 + 6 + msgp.IntSize + 7 + msgp.Float64Size + 12 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Connect) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "game":
			z.Game, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Game")
				return
			}
		case "auth_token":
			z.AuthToken, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AuthToken")
				return
			}
		case "protocol_version":
			z.ProtocolVersion, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProtocolVersion")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Connect) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Game == "" {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.AuthToken == "" {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ProtocolVersion == "" {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "type"
		err = en.Append(0xa4, 0x74, 0x79, 0x70, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Type)
		if err != nil {
			err = msgp.WrapError(err, "Type")
			return
		}
		// write "name"
		err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Name)
		if err != nil {
			err = msgp.WrapError(err, "Name")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "game"
			err = en.Append(0xa4, 0x67, 0x61, 0x6d, 0x65)
			if err != nil {
				return
			}
			err = en.WriteString(z.Game)
			if err != nil {
				err = msgp.WrapError(err, "Game")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "auth_token"
			err = en.Append(0xaa, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteString(z.AuthToken)
			if err != nil {
				err = msgp.WrapError(err, "AuthToken")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "protocol_version"
			err = en.Append(0xb0, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteString(z.ProtocolVersion)
			if err != nil {
				err = msgp.WrapError(err, "ProtocolVersion")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Connect) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Game == "" {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.AuthToken == "" {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ProtocolVersion == "" {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "type"
		o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, z.Type)
		// string "name"
		o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Name)
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "game"
			o = append(o, 0xa4, 0x67, 0x61, 0x6d, 0x65)
			o = msgp.AppendString(o, z.Game)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "auth_token"
			o = append(o, 0xaa, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
			o = msgp.AppendString(o, z.AuthToken)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "protocol_version"
			o = append(o, 0xb0, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
			o = msgp.AppendString(o, z.ProtocolVersion)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Connect) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "game":
			z.Game, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Game")
				return
			}
		case "auth_token":
			z.AuthToken, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AuthToken")
				return
			}
		case "protocol_version":
			z.ProtocolVersion, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProtocolVersion")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Connect) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 5 + msgp.StringPrefixSize + len(z.Name) + 5 + msgp.StringPrefixSize + len(z.Game) + 11 + msgp.StringPrefixSize + len(z.AuthToken) + 17 + msgp.StringPrefixSize + len(z.ProtocolVersion)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Error) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "code":
			z.Code, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "message":
			z.Message, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Message")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Error) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "type"
	err = en.Append(0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "code"
	err = en.Append(0xa4, 0x63, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Code)
	if err != nil {
		err = msgp.WrapError(err, "Code")
		return
	}
	// write "message"
	err = en.Append(0xa7, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Message)
	if err != nil {
		err = msgp.WrapError(err, "Message")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Error) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "code"
	o = append(o, 0xa4, 0x63, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.Code)
	// string "message"
	o = append(o, 0xa7, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65)
	o = msgp.AppendString(o, z.Message)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Error) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "code":
			z.Code, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "message":
			z.Message, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Message")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Error) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 5 + msgp.StringPrefixSize + len(z.Code) + 8 + msgp.StringPrefixSize + len(z.Message)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GameCompleted) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "game_id":
			z.GameID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "GameID")
				return
			}
		case "hands_completed":
			z.HandsCompleted, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "HandsCompleted")
				return
			}
		case "hand_limit":
			z.HandLimit, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "HandLimit")
				return
			}
		case "reason":
			z.Reason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Reason")
				return
			}
		case "seed":
			z.Seed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Seed")
				return
			}
		case "players":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Players")
				return
			}
			if cap(z.Players) >= int(zb0002) {
				z.Players = (z.Players)[:zb0002]
			} else {
				z.Players = make([]GameCompletedPlayer, zb0002)
			}
			for za0001 := range z.Players {
				err = z.Players[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Players", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *GameCompleted) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "type"
	err = en.Append(0x87, 0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "game_id"
	err = en.Append(0xa7, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.GameID)
	if err != nil {
		err = msgp.WrapError(err, "GameID")
		return
	}
	// write "hands_completed"
	err = en.Append(0xaf, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.HandsCompleted)
	if err != nil {
		err = msgp.WrapError(err, "HandsCompleted")
		return
	}
	// write "hand_limit"
	err = en.Append(0xaa, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.HandLimit)
	if err != nil {
		err = msgp.WrapError(err, "HandLimit")
		return
	}
	// write "reason"
	err = en.Append(0xa6, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Reason)
	if err != nil {
		err = msgp.WrapError(err, "Reason")
		return
	}
	// write "seed"
	err = en.Append(0xa4, 0x73, 0x65, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Seed)
	if err != nil {
		err = msgp.WrapError(err, "Seed")
		return
	}
	// write "players"
	err = en.Append(0xa7, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Players)))
	if err != nil {
		err = msgp.WrapError(err, "Players")
		return
	}
	for za0001 := range z.Players {
		err = z.Players[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Players", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GameCompleted) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "type"
	o = append(o, 0x87, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "game_id"
	o = append(o, 0xa7, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.GameID)
	// string "hands_completed"
	o = append(o, 0xaf, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.HandsCompleted)
	// string "hand_limit"
	o = append(o, 0xaa, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74)
	o = msgp.AppendUint64(o, z.HandLimit)
	// string "reason"
	o = append(o, 0xa6, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Reason)
	// string "seed"
	o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.Seed)
	// string "players"
	o = append(o, 0xa7, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Players)))
	for za0001 := range z.Players {
		o, err = z.Players[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Players", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GameCompleted) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "game_id":
			z.GameID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GameID")
				return
			}
		case "hands_completed":
			z.HandsCompleted, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HandsCompleted")
				return
			}
		case "hand_limit":
			z.HandLimit, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HandLimit")
				return
			}
		case "reason":
			z.Reason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reason")
				return
			}
		case "seed":
			z.Seed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Seed")
				return
			}
		case "players":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Players")
				return
			}
			if cap(z.Players) >= int(zb0002) {
				z.Players = (z.Players)[:zb0002]
			} else {
				z.Players = make([]GameCompletedPlayer, zb0002)
			}
			for za0001 := range z.Players {
				bts, err = z.Players[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Players", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GameCompleted) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 8 + msgp.StringPrefixSize + len(z.GameID) + 16 + msgp.Uint64Size + 11 + msgp.Uint64Size + 7 + msgp.StringPrefixSize + len(z.Reason) + 5 + msgp.Int64Size + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Players {
		s += z.Players[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GameCompletedPlayer) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bot_id":
			z.BotID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BotID")
				return
			}
		case "display_name":
			z.DisplayName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DisplayName")
				return
			}
		case "hands":
			z.Hands, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Hands")
				return
			}
		case "net_chips":
			z.NetChips, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "NetChips")
				return
			}
		case "avg_per_hand":
			z.AvgPerHand, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "AvgPerHand")
				return
			}
		case "total_won":
			z.TotalWon, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TotalWon")
				return
			}
		case "total_lost":
			z.TotalLost, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TotalLost")
				return
			}
		case "last_delta":
			z.LastDelta, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "LastDelta")
				return
			}
		case "timeouts":
			z.Timeouts, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Timeouts")
				return
			}
		case "invalid_actions":
			z.InvalidActions, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "InvalidActions")
				return
			}
		case "disconnects":
			z.Disconnects, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Disconnects")
				return
			}
		case "busts":
			z.Busts, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Busts")
				return
			}
		case "detailed_stats":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DetailedStats")
					return
				}
				z.DetailedStats = nil
			} else {
				if z.DetailedStats == nil {
					z.DetailedStats = new(PlayerDetailedStats)
				}
				err = z.DetailedStats.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "DetailedStats")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *GameCompletedPlayer) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	if z.DetailedStats == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "bot_id"
		err = en.Append(0xa6, 0x62, 0x6f, 0x74, 0x5f, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.BotID)
		if err != nil {
			err = msgp.WrapError(err, "BotID")
			return
		}
		// write "display_name"
		err = en.Append(0xac, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.DisplayName)
		if err != nil {
			err = msgp.WrapError(err, "DisplayName")
			return
		}
		// write "hands"
		err = en.Append(0xa5, 0x68, 0x61, 0x6e, 0x64, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Hands)
		if err != nil {
			err = msgp.WrapError(err, "Hands")
			return
		}
		// write "net_chips"
		err = en.Append(0xa9, 0x6e, 0x65, 0x74, 0x5f, 0x63, 0x68, 0x69, 0x70, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.NetChips)
		if err != nil {
			err = msgp.WrapError(err, "NetChips")
			return
		}
		// write "avg_per_hand"
		err = en.Append(0xac, 0x61, 0x76, 0x67, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.AvgPerHand)
		if err != nil {
			err = msgp.WrapError(err, "AvgPerHand")
			return
		}
		// write "total_won"
		err = en.Append(0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x77, 0x6f, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.TotalWon)
		if err != nil {
			err = msgp.WrapError(err, "TotalWon")
			return
		}
		// write "total_lost"
		err = en.Append(0xaa, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6c, 0x6f, 0x73, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.TotalLost)
		if err != nil {
			err = msgp.WrapError(err, "TotalLost")
			return
		}
		// write "last_delta"
		err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x64, 0x65, 0x6c, 0x74, 0x61)
		if err != nil {
			return
		}
		err = en.WriteInt(z.LastDelta)
		if err != nil {
			err = msgp.WrapError(err, "LastDelta")
			return
		}
		// write "timeouts"
		err = en.Append(0xa8, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Timeouts)
		if err != nil {
			err = msgp.WrapError(err, "Timeouts")
			return
		}
		// write "invalid_actions"
		err = en.Append(0xaf, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.InvalidActions)
		if err != nil {
			err = msgp.WrapError(err, "InvalidActions")
			return
		}
		// write "disconnects"
		err = en.Append(0xab, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Disconnects)
		if err != nil {
			err = msgp.WrapError(err, "Disconnects")
			return
		}
		// write "busts"
		err = en.Append(0xa5, 0x62, 0x75, 0x73, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Busts)
		if err != nil {
			err = msgp.WrapError(err, "Busts")
			return
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "detailed_stats"
			err = en.Append(0xae, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			if err != nil {
				return
			}
			if z.DetailedStats == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.DetailedStats.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "DetailedStats")
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GameCompletedPlayer) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	if z.DetailedStats == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "bot_id"
		o = append(o, 0xa6, 0x62, 0x6f, 0x74, 0x5f, 0x69, 0x64)
		o = msgp.AppendString(o, z.BotID)
		// string "display_name"
		o = append(o, 0xac, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.DisplayName)
		// string "hands"
		o = append(o, 0xa5, 0x68, 0x61, 0x6e, 0x64, 0x73)
		o = msgp.AppendInt(o, z.Hands)
		// string "net_chips"
		o = append(o, 0xa9, 0x6e, 0x65, 0x74, 0x5f, 0x63, 0x68, 0x69, 0x70, 0x73)
		o = msgp.AppendInt64(o, z.NetChips)
		// string "avg_per_hand"
		o = append(o, 0xac, 0x61, 0x76, 0x67, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
		o = msgp.AppendFloat64(o, z.AvgPerHand)
		// string "total_won"
		o = append(o, 0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x77, 0x6f, 0x6e)
		o = msgp.AppendInt64(o, z.TotalWon)
		// string "total_lost"
		o = append(o, 0xaa, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6c, 0x6f, 0x73, 0x74)
		o = msgp.AppendInt64(o, z.TotalLost)
		// string "last_delta"
		o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x64, 0x65, 0x6c, 0x74, 0x61)
		o = msgp.AppendInt(o, z.LastDelta)
		// string "timeouts"
		o = append(o, 0xa8, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x73)
		o = msgp.AppendInt(o, z.Timeouts)
		// string "invalid_actions"
		o = append(o, 0xaf, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
		o = msgp.AppendInt(o, z.InvalidActions)
		// string "disconnects"
		o = append(o, 0xab, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x73)
		o = msgp.AppendInt(o, z.Disconnects)
		// string "busts"
		o = append(o, 0xa5, 0x62, 0x75, 0x73, 0x74, 0x73)
		o = msgp.AppendInt(o, z.Busts)
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "detailed_stats"
			o = append(o, 0xae, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			if z.DetailedStats == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.DetailedStats.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "DetailedStats")
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GameCompletedPlayer) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bot_id":
			z.BotID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BotID")
				return
			}
		case "display_name":
			z.DisplayName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DisplayName")
				return
			}
		case "hands":
			z.Hands, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hands")
				return
			}
		case "net_chips":
			z.NetChips, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NetChips")
				return
			}
		case "avg_per_hand":
			z.AvgPerHand, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AvgPerHand")
				return
			}
		case "total_won":
			z.TotalWon, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalWon")
				return
			}
		case "total_lost":
			z.TotalLost, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalLost")
				return
			}
		case "last_delta":
			z.LastDelta, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastDelta")
				return
			}
		case "timeouts":
			z.Timeouts, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timeouts")
				return
			}
		case "invalid_actions":
			z.InvalidActions, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InvalidActions")
				return
			}
		case "disconnects":
			z.Disconnects, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Disconnects")
				return
			}
		case "busts":
			z.Busts, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Busts")
				return
			}
		case "detailed_stats":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DetailedStats = nil
			} else {
				if z.DetailedStats == nil {
					z.DetailedStats = new(PlayerDetailedStats)
				}
				bts, err = z.DetailedStats.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "DetailedStats")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GameCompletedPlayer) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.BotID) + 13 + msgp.StringPrefixSize + len(z.DisplayName) + 6 + msgp.IntSize + 10 + msgp.Int64Size + 13 + msgp.Float64Size + 10 + msgp.Int64Size + 11 + msgp.Int64Size + 11 + msgp.IntSize + 9 + msgp.IntSize + 16 + msgp.IntSize + 12 + msgp.IntSize + 6 + msgp.IntSize + 15
	if z.DetailedStats == nil {
		s += msgp.NilSize
	} else {
		s += z.DetailedStats.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GameUpdate) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "hand_id":
			z.HandID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HandID")
				return
			}
		case "pot":
			z.Pot, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Pot")
				return
			}
		case "players":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Players")
				return
			}
			if cap(z.Players) >= int(zb0002) {
				z.Players = (z.Players)[:zb0002]
			} else {
				z.Players = make([]Player, zb0002)
			}
			for za0001 := range z.Players {
				err = z.Players[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Players", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *GameUpdate) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "type"
	err = en.Append(0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "hand_id"
	err = en.Append(0xa7, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.HandID)
	if err != nil {
		err = msgp.WrapError(err, "HandID")
		return
	}
	// write "pot"
	err = en.Append(0xa3, 0x70, 0x6f, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Pot)
	if err != nil {
		err = msgp.WrapError(err, "Pot")
		return
	}
	// write "players"
	err = en.Append(0xa7, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Players)))
	if err != nil {
		err = msgp.WrapError(err, "Players")
		return
	}
	for za0001 := range z.Players {
		err = z.Players[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Players", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GameUpdate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "hand_id"
	o = append(o, 0xa7, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.HandID)
	// string "pot"
	o = append(o, 0xa3, 0x70, 0x6f, 0x74)
	o = msgp.AppendInt(o, z.Pot)
	// string "players"
	o = append(o, 0xa7, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Players)))
	for za0001 := range z.Players {
		o, err = z.Players[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Players", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GameUpdate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "hand_id":
			z.HandID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HandID")
				return
			}
		case "pot":
			z.Pot, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Pot")
				return
			}
		case "players":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Players")
				return
			}
			if cap(z.Players) >= int(zb0002) {
				z.Players = (z.Players)[:zb0002]
			} else {
				z.Players = make([]Player, zb0002)
			}
			for za0001 := range z.Players {
				bts, err = z.Players[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Players", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GameUpdate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 8 + msgp.StringPrefixSize + len(z.HandID) + 4 + msgp.IntSize + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Players {
		s += z.Players[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HandResult) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "hand_id":
			z.HandID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HandID")
				return
			}
		case "winners":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Winners")
				return
			}
			if cap(z.Winners) >= int(zb0002) {
				z.Winners = (z.Winners)[:zb0002]
			} else {
				z.Winners = make([]Winner, zb0002)
			}
			for za0001 := range z.Winners {
				err = z.Winners[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Winners", za0001)
					return
				}
			}
		case "board":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Board")
				return
			}
			if cap(z.Board) >= int(zb0003) {
				z.Board = (z.Board)[:zb0003]
			} else {
				z.Board = make([]string, zb0003)
			}
			for za0002 := range z.Board {
				z.Board[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Board", za0002)
					return
				}
			}
		case "showdown":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Showdown")
				return
			}
			if cap(z.Showdown) >= int(zb0004) {
				z.Showdown = (z.Showdown)[:zb0004]
			} else {
				z.Showdown = make([]ShowdownHand, zb0004)
			}
			for za0003 := range z.Showdown {
				err = z.Showdown[za0003].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Showdown", za0003)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HandResult) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Showdown == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "type"
		err = en.Append(0xa4, 0x74, 0x79, 0x70, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Type)
		if err != nil {
			err = msgp.WrapError(err, "Type")
			return
		}
		// write "hand_id"
		err = en.Append(0xa7, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.HandID)
		if err != nil {
			err = msgp.WrapError(err, "HandID")
			return
		}
		// write "winners"
		err = en.Append(0xa7, 0x77, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Winners)))
		if err != nil {
			err = msgp.WrapError(err, "Winners")
			return
		}
		for za0001 := range z.Winners {
			err = z.Winners[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Winners", za0001)
				return
			}
		}
		// write "board"
		err = en.Append(0xa5, 0x62, 0x6f, 0x61, 0x72, 0x64)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Board)))
		if err != nil {
			err = msgp.WrapError(err, "Board")
			return
		}
		for za0002 := range z.Board {
			err = en.WriteString(z.Board[za0002])
			if err != nil {
				err = msgp.WrapError(err, "Board", za0002)
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "showdown"
			err = en.Append(0xa8, 0x73, 0x68, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.Showdown)))
			if err != nil {
				err = msgp.WrapError(err, "Showdown")
				return
			}
			for za0003 := range z.Showdown {
				err = z.Showdown[za0003].EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Showdown", za0003)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HandResult) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Showdown == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "type"
		o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, z.Type)
		// string "hand_id"
		o = append(o, 0xa7, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x69, 0x64)
		o = msgp.AppendString(o, z.HandID)
		// string "winners"
		o = append(o, 0xa7, 0x77, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Winners)))
		for za0001 := range z.Winners {
			o, err = z.Winners[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Winners", za0001)
				return
			}
		}
		// string "board"
		o = append(o, 0xa5, 0x62, 0x6f, 0x61, 0x72, 0x64)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Board)))
		for za0002 := range z.Board {
			o = msgp.AppendString(o, z.Board[za0002])
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "showdown"
			o = append(o, 0xa8, 0x73, 0x68, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e)
			o = msgp.AppendArrayHeader(o, uint32(len(z.Showdown)))
			for za0003 := range z.Showdown {
				o, err = z.Showdown[za0003].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Showdown", za0003)
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HandResult) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "hand_id":
			z.HandID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HandID")
				return
			}
		case "winners":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Winners")
				return
			}
			if cap(z.Winners) >= int(zb0002) {
				z.Winners = (z.Winners)[:zb0002]
			} else {
				z.Winners = make([]Winner, zb0002)
			}
			for za0001 := range z.Winners {
				bts, err = z.Winners[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Winners", za0001)
					return
				}
			}
		case "board":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Board")
				return
			}
			if cap(z.Board) >= int(zb0003) {
				z.Board = (z.Board)[:zb0003]
			} else {
				z.Board = make([]string, zb0003)
			}
			for za0002 := range z.Board {
				z.Board[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Board", za0002)
					return
				}
			}
		case "showdown":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Showdown")
				return
			}
			if cap(z.Showdown) >= int(zb0004) {
				z.Showdown = (z.Showdown)[:zb0004]
			} else {
				z.Showdown = make([]ShowdownHand, zb0004)
			}
			for za0003 := range z.Showdown {
				bts, err = z.Showdown[za0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Showdown", za0003)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HandResult) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 8 + msgp.StringPrefixSize + len(z.HandID) + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Winners {
		s += z.Winners[za0001].Msgsize()
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Board {
		s += msgp.StringPrefixSize + len(z.Board[za0002])
	}
	s += 9 + msgp.ArrayHeaderSize
	for za0003 := range z.Showdown {
		s += z.Showdown[za0003].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HandStart) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "hand_id":
			z.HandID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HandID")
				return
			}
		case "hole_cards":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "HoleCards")
				return
			}
			if cap(z.HoleCards) >= int(zb0002) {
				z.HoleCards = (z.HoleCards)[:zb0002]
			} else {
				z.HoleCards = make([]string, zb0002)
			}
			for za0001 := range z.HoleCards {
				z.HoleCards[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "HoleCards", za0001)
					return
				}
			}
		case "your_seat":
			z.YourSeat, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "YourSeat")
				return
			}
		case "button":
			z.Button, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Button")
				return
			}
		case "players":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Players")
				return
			}
			if cap(z.Players) >= int(zb0003) {
				z.Players = (z.Players)[:zb0003]
			} else {
				z.Players = make([]Player, zb0003)
			}
			for za0002 := range z.Players {
				err = z.Players[za0002].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Players", za0002)
					return
				}
			}
		case "small_blind":
			z.SmallBlind, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SmallBlind")
				return
			}
		case "big_blind":
			z.BigBlind, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BigBlind")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HandStart) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "type"
	err = en.Append(0x88, 0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "hand_id"
	err = en.Append(0xa7, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.HandID)
	if err != nil {
		err = msgp.WrapError(err, "HandID")
		return
	}
	// write "hole_cards"
	err = en.Append(0xaa, 0x68, 0x6f, 0x6c, 0x65, 0x5f, 0x63, 0x61, 0x72, 0x64, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.HoleCards)))
	if err != nil {
		err = msgp.WrapError(err, "HoleCards")
		return
	}
	for za0001 := range z.HoleCards {
		err = en.WriteString(z.HoleCards[za0001])
		if err != nil {
			err = msgp.WrapError(err, "HoleCards", za0001)
			return
		}
	}
	// write "your_seat"
	err = en.Append(0xa9, 0x79, 0x6f, 0x75, 0x72, 0x5f, 0x73, 0x65, 0x61, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.YourSeat)
	if err != nil {
		err = msgp.WrapError(err, "YourSeat")
		return
	}
	// write "button"
	err = en.Append(0xa6, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Button)
	if err != nil {
		err = msgp.WrapError(err, "Button")
		return
	}
	// write "players"
	err = en.Append(0xa7, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Players)))
	if err != nil {
		err = msgp.WrapError(err, "Players")
		return
	}
	for za0002 := range z.Players {
		err = z.Players[za0002].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Players", za0002)
			return
		}
	}
	// write "small_blind"
	err = en.Append(0xab, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x5f, 0x62, 0x6c, 0x69, 0x6e, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SmallBlind)
	if err != nil {
		err = msgp.WrapError(err, "SmallBlind")
		return
	}
	// write "big_blind"
	err = en.Append(0xa9, 0x62, 0x69, 0x67, 0x5f, 0x62, 0x6c, 0x69, 0x6e, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BigBlind)
	if err != nil {
		err = msgp.WrapError(err, "BigBlind")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HandStart) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "type"
	o = append(o, 0x88, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "hand_id"
	o = append(o, 0xa7, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.HandID)
	// string "hole_cards"
	o = append(o, 0xaa, 0x68, 0x6f, 0x6c, 0x65, 0x5f, 0x63, 0x61, 0x72, 0x64, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.HoleCards)))
	for za0001 := range z.HoleCards {
		o = msgp.AppendString(o, z.HoleCards[za0001])
	}
	// string "your_seat"
	o = append(o, 0xa9, 0x79, 0x6f, 0x75, 0x72, 0x5f, 0x73, 0x65, 0x61, 0x74)
	o = msgp.AppendInt(o, z.YourSeat)
	// string "button"
	o = append(o, 0xa6, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Button)
	// string "players"
	o = append(o, 0xa7, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Players)))
	for za0002 := range z.Players {
		o, err = z.Players[za0002].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Players", za0002)
			return
		}
	}
	// string "small_blind"
	o = append(o, 0xab, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x5f, 0x62, 0x6c, 0x69, 0x6e, 0x64)
	o = msgp.AppendInt(o, z.SmallBlind)
	// string "big_blind"
	o = append(o, 0xa9, 0x62, 0x69, 0x67, 0x5f, 0x62, 0x6c, 0x69, 0x6e, 0x64)
	o = msgp.AppendInt(o, z.BigBlind)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HandStart) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "hand_id":
			z.HandID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HandID")
				return
			}
		case "hole_cards":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HoleCards")
				return
			}
			if cap(z.HoleCards) >= int(zb0002) {
				z.HoleCards = (z.HoleCards)[:zb0002]
			} else {
				z.HoleCards = make([]string, zb0002)
			}
			for za0001 := range z.HoleCards {
				z.HoleCards[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HoleCards", za0001)
					return
				}
			}
		case "your_seat":
			z.YourSeat, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "YourSeat")
				return
			}
		case "button":
			z.Button, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Button")
				return
			}
		case "players":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Players")
				return
			}
			if cap(z.Players) >= int(zb0003) {
				z.Players = (z.Players)[:zb0003]
			} else {
				z.Players = make([]Player, zb0003)
			}
			for za0002 := range z.Players {
				bts, err = z.Players[za0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Players", za0002)
					return
				}
			}
		case "small_blind":
			z.SmallBlind, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SmallBlind")
				return
			}
		case "big_blind":
			z.BigBlind, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BigBlind")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HandStart) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 8 + msgp.StringPrefixSize + len(z.HandID) + 11 + msgp.ArrayHeaderSize
	for za0001 := range z.HoleCards {
		s += msgp.StringPrefixSize + len(z.HoleCards[za0001])
	}
	s += 10 + msgp.IntSize + 7 + msgp.IntSize + 8 + msgp.ArrayHeaderSize
	for za0002 := range z.Players {
		s += z.Players[za0002].Msgsize()
	}
	s += 12 + msgp.IntSize + 10 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MessageType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MessageType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MessageType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MessageType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MessageType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MessageType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Player) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "seat":
			z.Seat, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Seat")
				return
			}
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "chips":
			z.Chips, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Chips")
				return
			}
		case "bet":
			z.Bet, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Bet")
				return
			}
		case "folded":
			z.Folded, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Folded")
				return
			}
		case "all_in":
			z.AllIn, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "AllIn")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Player) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 6 bits */
	_ = zb0001Mask
	if z.Bet == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Folded == false {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.AllIn == false {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "seat"
		err = en.Append(0xa4, 0x73, 0x65, 0x61, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Seat)
		if err != nil {
			err = msgp.WrapError(err, "Seat")
			return
		}
		// write "name"
		err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Name)
		if err != nil {
			err = msgp.WrapError(err, "Name")
			return
		}
		// write "chips"
		err = en.Append(0xa5, 0x63, 0x68, 0x69, 0x70, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Chips)
		if err != nil {
			err = msgp.WrapError(err, "Chips")
			return
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "bet"
			err = en.Append(0xa3, 0x62, 0x65, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Bet)
			if err != nil {
				err = msgp.WrapError(err, "Bet")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "folded"
			err = en.Append(0xa6, 0x66, 0x6f, 0x6c, 0x64, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteBool(z.Folded)
			if err != nil {
				err = msgp.WrapError(err, "Folded")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "all_in"
			err = en.Append(0xa6, 0x61, 0x6c, 0x6c, 0x5f, 0x69, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteBool(z.AllIn)
			if err != nil {
				err = msgp.WrapError(err, "AllIn")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Player) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 6 bits */
	_ = zb0001Mask
	if z.Bet == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Folded == false {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.AllIn == false {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "seat"
		o = append(o, 0xa4, 0x73, 0x65, 0x61, 0x74)
		o = msgp.AppendInt(o, z.Seat)
		// string "name"
		o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Name)
		// string "chips"
		o = append(o, 0xa5, 0x63, 0x68, 0x69, 0x70, 0x73)
		o = msgp.AppendInt(o, z.Chips)
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "bet"
			o = append(o, 0xa3, 0x62, 0x65, 0x74)
			o = msgp.AppendInt(o, z.Bet)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "folded"
			o = append(o, 0xa6, 0x66, 0x6f, 0x6c, 0x64, 0x65, 0x64)
			o = msgp.AppendBool(o, z.Folded)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "all_in"
			o = append(o, 0xa6, 0x61, 0x6c, 0x6c, 0x5f, 0x69, 0x6e)
			o = msgp.AppendBool(o, z.AllIn)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Player) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "seat":
			z.Seat, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Seat")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "chips":
			z.Chips, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Chips")
				return
			}
		case "bet":
			z.Bet, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bet")
				return
			}
		case "folded":
			z.Folded, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Folded")
				return
			}
		case "all_in":
			z.AllIn, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllIn")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Player) Msgsize() (s int) {
	s = 1 + 5 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Name) + 6 + msgp.IntSize + 4 + msgp.IntSize + 7 + msgp.BoolSize + 7 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PlayerAction) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "hand_id":
			z.HandID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HandID")
				return
			}
		case "street":
			z.Street, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Street")
				return
			}
		case "seat":
			z.Seat, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Seat")
				return
			}
		case "player_name":
			z.PlayerName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "PlayerName")
				return
			}
		case "action":
			z.Action, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Action")
				return
			}
		case "amount_paid":
			z.AmountPaid, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AmountPaid")
				return
			}
		case "player_bet":
			z.PlayerBet, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PlayerBet")
				return
			}
		case "player_chips":
			z.PlayerChips, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PlayerChips")
				return
			}
		case "pot":
			z.Pot, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Pot")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PlayerAction) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 10
	// write "type"
	err = en.Append(0x8a, 0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "hand_id"
	err = en.Append(0xa7, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.HandID)
	if err != nil {
		err = msgp.WrapError(err, "HandID")
		return
	}
	// write "street"
	err = en.Append(0xa6, 0x73, 0x74, 0x72, 0x65, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Street)
	if err != nil {
		err = msgp.WrapError(err, "Street")
		return
	}
	// write "seat"
	err = en.Append(0xa4, 0x73, 0x65, 0x61, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Seat)
	if err != nil {
		err = msgp.WrapError(err, "Seat")
		return
	}
	// write "player_name"
	err = en.Append(0xab, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.PlayerName)
	if err != nil {
		err = msgp.WrapError(err, "PlayerName")
		return
	}
	// write "action"
	err = en.Append(0xa6, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Action)
	if err != nil {
		err = msgp.WrapError(err, "Action")
		return
	}
	// write "amount_paid"
	err = en.Append(0xab, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x70, 0x61, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AmountPaid)
	if err != nil {
		err = msgp.WrapError(err, "AmountPaid")
		return
	}
	// write "player_bet"
	err = en.Append(0xaa, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x62, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PlayerBet)
	if err != nil {
		err = msgp.WrapError(err, "PlayerBet")
		return
	}
	// write "player_chips"
	err = en.Append(0xac, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x63, 0x68, 0x69, 0x70, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PlayerChips)
	if err != nil {
		err = msgp.WrapError(err, "PlayerChips")
		return
	}
	// write "pot"
	err = en.Append(0xa3, 0x70, 0x6f, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Pot)
	if err != nil {
		err = msgp.WrapError(err, "Pot")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PlayerAction) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "type"
	o = append(o, 0x8a, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "hand_id"
	o = append(o, 0xa7, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.HandID)
	// string "street"
	o = append(o, 0xa6, 0x73, 0x74, 0x72, 0x65, 0x65, 0x74)
	o = msgp.AppendString(o, z.Street)
	// string "seat"
	o = append(o, 0xa4, 0x73, 0x65, 0x61, 0x74)
	o = msgp.AppendInt(o, z.Seat)
	// string "player_name"
	o = append(o, 0xab, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.PlayerName)
	// string "action"
	o = append(o, 0xa6, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Action)
	// string "amount_paid"
	o = append(o, 0xab, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x70, 0x61, 0x69, 0x64)
	o = msgp.AppendInt(o, z.AmountPaid)
	// string "player_bet"
	o = append(o, 0xaa, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x62, 0x65, 0x74)
	o = msgp.AppendInt(o, z.PlayerBet)
	// string "player_chips"
	o = append(o, 0xac, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x63, 0x68, 0x69, 0x70, 0x73)
	o = msgp.AppendInt(o, z.PlayerChips)
	// string "pot"
	o = append(o, 0xa3, 0x70, 0x6f, 0x74)
	o = msgp.AppendInt(o, z.Pot)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PlayerAction) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "hand_id":
			z.HandID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HandID")
				return
			}
		case "street":
			z.Street, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Street")
				return
			}
		case "seat":
			z.Seat, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Seat")
				return
			}
		case "player_name":
			z.PlayerName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlayerName")
				return
			}
		case "action":
			z.Action, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Action")
				return
			}
		case "amount_paid":
			z.AmountPaid, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AmountPaid")
				return
			}
		case "player_bet":
			z.PlayerBet, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlayerBet")
				return
			}
		case "player_chips":
			z.PlayerChips, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlayerChips")
				return
			}
		case "pot":
			z.Pot, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Pot")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PlayerAction) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 8 + msgp.StringPrefixSize + len(z.HandID) + 7 + msgp.StringPrefixSize + len(z.Street) + 5 + msgp.IntSize + 12 + msgp.StringPrefixSize + len(z.PlayerName) + 7 + msgp.StringPrefixSize + len(z.Action) + 12 + msgp.IntSize + 11 + msgp.IntSize + 13 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PlayerDetailedStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "hands":
			z.Hands, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Hands")
				return
			}
		case "net_bb":
			z.NetBB, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "NetBB")
				return
			}
		case "bb_per_100":
			z.BB100, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BB100")
				return
			}
		case "mean":
			z.Mean, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Mean")
				return
			}
		case "median":
			z.Median, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Median")
				return
			}
		case "std_dev":
			z.StdDev, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "StdDev")
				return
			}
		case "ci_95_low":
			z.CI95Low, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CI95Low")
				return
			}
		case "ci_95_high":
			z.CI95High, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CI95High")
				return
			}
		case "winning_hands":
			z.WinningHands, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "WinningHands")
				return
			}
		case "win_rate":
			z.WinRate, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WinRate")
				return
			}
		case "showdown_wins":
			z.ShowdownWins, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ShowdownWins")
				return
			}
		case "non_showdown_wins":
			z.NonShowdownWins, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "NonShowdownWins")
				return
			}
		case "showdown_win_rate":
			z.ShowdownWinRate, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ShowdownWinRate")
				return
			}
		case "showdown_bb":
			z.ShowdownBB, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ShowdownBB")
				return
			}
		case "non_showdown_bb":
			z.NonShowdownBB, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "NonShowdownBB")
				return
			}
		case "max_pot_bb":
			z.MaxPotBB, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxPotBB")
				return
			}
		case "big_pots":
			z.BigPots, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BigPots")
				return
			}
		case "vpip":
			z.VPIP, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "VPIP")
				return
			}
		case "pfr":
			z.PFR, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "PFR")
				return
			}
		case "timeouts":
			z.Timeouts, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Timeouts")
				return
			}
		case "busts":
			z.Busts, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Busts")
				return
			}
		case "responses_tracked":
			z.ResponsesTracked, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ResponsesTracked")
				return
			}
		case "avg_response_ms":
			z.AvgResponseMs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "AvgResponseMs")
				return
			}
		case "p95_response_ms":
			z.P95ResponseMs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "P95ResponseMs")
				return
			}
		case "max_response_ms":
			z.MaxResponseMs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxResponseMs")
				return
			}
		case "min_response_ms":
			z.MinResponseMs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MinResponseMs")
				return
			}
		case "response_std_ms":
			z.ResponseStdMs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ResponseStdMs")
				return
			}
		case "response_timeouts":
			z.ResponseTimeouts, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ResponseTimeouts")
				return
			}
		case "response_disconnects":
			z.ResponseDisconnects, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ResponseDisconnects")
				return
			}
		case "position_stats":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "PositionStats")
				return
			}
			if z.PositionStats == nil {
				z.PositionStats = make(map[string]PositionStatSummary, zb0002)
			} else if len(z.PositionStats) > 0 {
				clear(z.PositionStats)
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "PositionStats")
					return
				}
				var za0002 PositionStatSummary
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "PositionStats", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "PositionStats", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "hands":
						za0002.Hands, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "PositionStats", za0001, "Hands")
							return
						}
					case "net_bb":
						za0002.NetBB, err = dc.ReadFloat64()
						if err != nil {
							err = msgp.WrapError(err, "PositionStats", za0001, "NetBB")
							return
						}
					case "bb_per_hand":
						za0002.BBPerHand, err = dc.ReadFloat64()
						if err != nil {
							err = msgp.WrapError(err, "PositionStats", za0001, "BBPerHand")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "PositionStats", za0001)
							return
						}
					}
				}
				z.PositionStats[za0001] = za0002
			}
		case "street_stats":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "StreetStats")
				return
			}
			if z.StreetStats == nil {
				z.StreetStats = make(map[string]StreetStatSummary, zb0004)
			} else if len(z.StreetStats) > 0 {
				clear(z.StreetStats)
			}
			for zb0004 > 0 {
				zb0004--
				var za0003 string
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "StreetStats")
					return
				}
				var za0004 StreetStatSummary
				var zb0005 uint32
				zb0005, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "StreetStats", za0003)
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "StreetStats", za0003)
						return
					}
					switch msgp.UnsafeString(field) {
					case "hands_ended":
						za0004.HandsEnded, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "StreetStats", za0003, "HandsEnded")
							return
						}
					case "net_bb":
						za0004.NetBB, err = dc.ReadFloat64()
						if err != nil {
							err = msgp.WrapError(err, "StreetStats", za0003, "NetBB")
							return
						}
					case "bb_per_hand":
						za0004.BBPerHand, err = dc.ReadFloat64()
						if err != nil {
							err = msgp.WrapError(err, "StreetStats", za0003, "BBPerHand")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "StreetStats", za0003)
							return
						}
					}
				}
				z.StreetStats[za0003] = za0004
			}
		case "hand_category_stats":
			var zb0006 uint32
			zb0006, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "HandCategoryStats")
				return
			}
			if z.HandCategoryStats == nil {
				z.HandCategoryStats = make(map[string]CategoryStatSummary, zb0006)
			} else if len(z.HandCategoryStats) > 0 {
				clear(z.HandCategoryStats)
			}
			for zb0006 > 0 {
				zb0006--
				var za0005 string
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "HandCategoryStats")
					return
				}
				var za0006 CategoryStatSummary
				var zb0007 uint32
				zb0007, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "HandCategoryStats", za0005)
					return
				}
				for zb0007 > 0 {
					zb0007--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "HandCategoryStats", za0005)
						return
					}
					switch msgp.UnsafeString(field) {
					case "hands":
						za0006.Hands, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "HandCategoryStats", za0005, "Hands")
							return
						}
					case "net_bb":
						za0006.NetBB, err = dc.ReadFloat64()
						if err != nil {
							err = msgp.WrapError(err, "HandCategoryStats", za0005, "NetBB")
							return
						}
					case "bb_per_hand":
						za0006.BBPerHand, err = dc.ReadFloat64()
						if err != nil {
							err = msgp.WrapError(err, "HandCategoryStats", za0005, "BBPerHand")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "HandCategoryStats", za0005)
							return
						}
					}
				}
				z.HandCategoryStats[za0005] = za0006
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PlayerDetailedStats) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(32)
	var zb0001Mask uint32 /* 32 bits */
	_ = zb0001Mask
	if z.PositionStats == nil {
		zb0001Len--
		zb0001Mask |= 0x20000000
	}
	if z.StreetStats == nil {
		zb0001Len--
		zb0001Mask |= 0x40000000
	}
	if z.HandCategoryStats == nil {
		zb0001Len--
		zb0001Mask |= 0x80000000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "hands"
		err = en.Append(0xa5, 0x68, 0x61, 0x6e, 0x64, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Hands)
		if err != nil {
			err = msgp.WrapError(err, "Hands")
			return
		}
		// write "net_bb"
		err = en.Append(0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.NetBB)
		if err != nil {
			err = msgp.WrapError(err, "NetBB")
			return
		}
		// write "bb_per_100"
		err = en.Append(0xaa, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x31, 0x30, 0x30)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.BB100)
		if err != nil {
			err = msgp.WrapError(err, "BB100")
			return
		}
		// write "mean"
		err = en.Append(0xa4, 0x6d, 0x65, 0x61, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.Mean)
		if err != nil {
			err = msgp.WrapError(err, "Mean")
			return
		}
		// write "median"
		err = en.Append(0xa6, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.Median)
		if err != nil {
			err = msgp.WrapError(err, "Median")
			return
		}
		// write "std_dev"
		err = en.Append(0xa7, 0x73, 0x74, 0x64, 0x5f, 0x64, 0x65, 0x76)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.StdDev)
		if err != nil {
			err = msgp.WrapError(err, "StdDev")
			return
		}
		// write "ci_95_low"
		err = en.Append(0xa9, 0x63, 0x69, 0x5f, 0x39, 0x35, 0x5f, 0x6c, 0x6f, 0x77)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.CI95Low)
		if err != nil {
			err = msgp.WrapError(err, "CI95Low")
			return
		}
		// write "ci_95_high"
		err = en.Append(0xaa, 0x63, 0x69, 0x5f, 0x39, 0x35, 0x5f, 0x68, 0x69, 0x67, 0x68)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.CI95High)
		if err != nil {
			err = msgp.WrapError(err, "CI95High")
			return
		}
		// write "winning_hands"
		err = en.Append(0xad, 0x77, 0x69, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.WinningHands)
		if err != nil {
			err = msgp.WrapError(err, "WinningHands")
			return
		}
		// write "win_rate"
		err = en.Append(0xa8, 0x77, 0x69, 0x6e, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.WinRate)
		if err != nil {
			err = msgp.WrapError(err, "WinRate")
			return
		}
		// write "showdown_wins"
		err = en.Append(0xad, 0x73, 0x68, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x77, 0x69, 0x6e, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.ShowdownWins)
		if err != nil {
			err = msgp.WrapError(err, "ShowdownWins")
			return
		}
		// write "non_showdown_wins"
		err = en.Append(0xb1, 0x6e, 0x6f, 0x6e, 0x5f, 0x73, 0x68, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x77, 0x69, 0x6e, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.NonShowdownWins)
		if err != nil {
			err = msgp.WrapError(err, "NonShowdownWins")
			return
		}
		// write "showdown_win_rate"
		err = en.Append(0xb1, 0x73, 0x68, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x77, 0x69, 0x6e, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.ShowdownWinRate)
		if err != nil {
			err = msgp.WrapError(err, "ShowdownWinRate")
			return
		}
		// write "showdown_bb"
		err = en.Append(0xab, 0x73, 0x68, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x62, 0x62)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.ShowdownBB)
		if err != nil {
			err = msgp.WrapError(err, "ShowdownBB")
			return
		}
		// write "non_showdown_bb"
		err = en.Append(0xaf, 0x6e, 0x6f, 0x6e, 0x5f, 0x73, 0x68, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x62, 0x62)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.NonShowdownBB)
		if err != nil {
			err = msgp.WrapError(err, "NonShowdownBB")
			return
		}
		// write "max_pot_bb"
		err = en.Append(0xaa, 0x6d, 0x61, 0x78, 0x5f, 0x70, 0x6f, 0x74, 0x5f, 0x62, 0x62)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.MaxPotBB)
		if err != nil {
			err = msgp.WrapError(err, "MaxPotBB")
			return
		}
		// write "big_pots"
		err = en.Append(0xa8, 0x62, 0x69, 0x67, 0x5f, 0x70, 0x6f, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.BigPots)
		if err != nil {
			err = msgp.WrapError(err, "BigPots")
			return
		}
		// write "vpip"
		err = en.Append(0xa4, 0x76, 0x70, 0x69, 0x70)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.VPIP)
		if err != nil {
			err = msgp.WrapError(err, "VPIP")
			return
		}
		// write "pfr"
		err = en.Append(0xa3, 0x70, 0x66, 0x72)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.PFR)
		if err != nil {
			err = msgp.WrapError(err, "PFR")
			return
		}
		// write "timeouts"
		err = en.Append(0xa8, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Timeouts)
		if err != nil {
			err = msgp.WrapError(err, "Timeouts")
			return
		}
		// write "busts"
		err = en.Append(0xa5, 0x62, 0x75, 0x73, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Busts)
		if err != nil {
			err = msgp.WrapError(err, "Busts")
			return
		}
		// write "responses_tracked"
		err = en.Append(0xb1, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x5f, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteInt(z.ResponsesTracked)
		if err != nil {
			err = msgp.WrapError(err, "ResponsesTracked")
			return
		}
		// write "avg_response_ms"
		err = en.Append(0xaf, 0x61, 0x76, 0x67, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x6d, 0x73)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.AvgResponseMs)
		if err != nil {
			err = msgp.WrapError(err, "AvgResponseMs")
			return
		}
		// write "p95_response_ms"
		err = en.Append(0xaf, 0x70, 0x39, 0x35, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x6d, 0x73)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.P95ResponseMs)
		if err != nil {
			err = msgp.WrapError(err, "P95ResponseMs")
			return
		}
		// write "max_response_ms"
		err = en.Append(0xaf, 0x6d, 0x61, 0x78, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x6d, 0x73)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.MaxResponseMs)
		if err != nil {
			err = msgp.WrapError(err, "MaxResponseMs")
			return
		}
		// write "min_response_ms"
		err = en.Append(0xaf, 0x6d, 0x69, 0x6e, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x6d, 0x73)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.MinResponseMs)
		if err != nil {
			err = msgp.WrapError(err, "MinResponseMs")
			return
		}
		// write "response_std_ms"
		err = en.Append(0xaf, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x73, 0x74, 0x64, 0x5f, 0x6d, 0x73)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.ResponseStdMs)
		if err != nil {
			err = msgp.WrapError(err, "ResponseStdMs")
			return
		}
		// write "response_timeouts"
		err = en.Append(0xb1, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.ResponseTimeouts)
		if err != nil {
			err = msgp.WrapError(err, "ResponseTimeouts")
			return
		}
		// write "response_disconnects"
		err = en.Append(0xb4, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.ResponseDisconnects)
		if err != nil {
			err = msgp.WrapError(err, "ResponseDisconnects")
			return
		}
		if (zb0001Mask & 0x20000000) == 0 { // if not omitted
			// write "position_stats"
			err = en.Append(0xae, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.PositionStats)))
			if err != nil {
				err = msgp.WrapError(err, "PositionStats")
				return
			}
			for za0001, za0002 := range z.PositionStats {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "PositionStats")
					return
				}
				// map header, size 3
				// write "hands"
				err = en.Append(0x83, 0xa5, 0x68, 0x61, 0x6e, 0x64, 0x73)
				if err != nil {
					return
				}
				err = en.WriteInt(za0002.Hands)
				if err != nil {
					err = msgp.WrapError(err, "PositionStats", za0001, "Hands")
					return
				}
				// write "net_bb"
				err = en.Append(0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
				if err != nil {
					return
				}
				err = en.WriteFloat64(za0002.NetBB)
				if err != nil {
					err = msgp.WrapError(err, "PositionStats", za0001, "NetBB")
					return
				}
				// write "bb_per_hand"
				err = en.Append(0xab, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
				if err != nil {
					return
				}
				err = en.WriteFloat64(za0002.BBPerHand)
				if err != nil {
					err = msgp.WrapError(err, "PositionStats", za0001, "BBPerHand")
					return
				}
			}
		}
		if (zb0001Mask & 0x40000000) == 0 { // if not omitted
			// write "street_stats"
			err = en.Append(0xac, 0x73, 0x74, 0x72, 0x65, 0x65, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.StreetStats)))
			if err != nil {
				err = msgp.WrapError(err, "StreetStats")
				return
			}
			for za0003, za0004 := range z.StreetStats {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "StreetStats")
					return
				}
				// map header, size 3
				// write "hands_ended"
				err = en.Append(0x83, 0xab, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x5f, 0x65, 0x6e, 0x64, 0x65, 0x64)
				if err != nil {
					return
				}
				err = en.WriteInt(za0004.HandsEnded)
				if err != nil {
					err = msgp.WrapError(err, "StreetStats", za0003, "HandsEnded")
					return
				}
				// write "net_bb"
				err = en.Append(0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
				if err != nil {
					return
				}
				err = en.WriteFloat64(za0004.NetBB)
				if err != nil {
					err = msgp.WrapError(err, "StreetStats", za0003, "NetBB")
					return
				}
				// write "bb_per_hand"
				err = en.Append(0xab, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
				if err != nil {
					return
				}
				err = en.WriteFloat64(za0004.BBPerHand)
				if err != nil {
					err = msgp.WrapError(err, "StreetStats", za0003, "BBPerHand")
					return
				}
			}
		}
		if (zb0001Mask & 0x80000000) == 0 { // if not omitted
			// write "hand_category_stats"
			err = en.Append(0xb3, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.HandCategoryStats)))
			if err != nil {
				err = msgp.WrapError(err, "HandCategoryStats")
				return
			}
			for za0005, za0006 := range z.HandCategoryStats {
				err = en.WriteString(za0005)
				if err != nil {
					err = msgp.WrapError(err, "HandCategoryStats")
					return
				}
				// map header, size 3
				// write "hands"
				err = en.Append(0x83, 0xa5, 0x68, 0x61, 0x6e, 0x64, 0x73)
				if err != nil {
					return
				}
				err = en.WriteInt(za0006.Hands)
				if err != nil {
					err = msgp.WrapError(err, "HandCategoryStats", za0005, "Hands")
					return
				}
				// write "net_bb"
				err = en.Append(0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
				if err != nil {
					return
				}
				err = en.WriteFloat64(za0006.NetBB)
				if err != nil {
					err = msgp.WrapError(err, "HandCategoryStats", za0005, "NetBB")
					return
				}
				// write "bb_per_hand"
				err = en.Append(0xab, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
				if err != nil {
					return
				}
				err = en.WriteFloat64(za0006.BBPerHand)
				if err != nil {
					err = msgp.WrapError(err, "HandCategoryStats", za0005, "BBPerHand")
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PlayerDetailedStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(32)
	var zb0001Mask uint32 /* 32 bits */
	_ = zb0001Mask
	if z.PositionStats == nil {
		zb0001Len--
		zb0001Mask |= 0x20000000
	}
	if z.StreetStats == nil {
		zb0001Len--
		zb0001Mask |= 0x40000000
	}
	if z.HandCategoryStats == nil {
		zb0001Len--
		zb0001Mask |= 0x80000000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "hands"
		o = append(o, 0xa5, 0x68, 0x61, 0x6e, 0x64, 0x73)
		o = msgp.AppendInt(o, z.Hands)
		// string "net_bb"
		o = append(o, 0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
		o = msgp.AppendFloat64(o, z.NetBB)
		// string "bb_per_100"
		o = append(o, 0xaa, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x31, 0x30, 0x30)
		o = msgp.AppendFloat64(o, z.BB100)
		// string "mean"
		o = append(o, 0xa4, 0x6d, 0x65, 0x61, 0x6e)
		o = msgp.AppendFloat64(o, z.Mean)
		// string "median"
		o = append(o, 0xa6, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x6e)
		o = msgp.AppendFloat64(o, z.Median)
		// string "std_dev"
		o = append(o, 0xa7, 0x73, 0x74, 0x64, 0x5f, 0x64, 0x65, 0x76)
		o = msgp.AppendFloat64(o, z.StdDev)
		// string "ci_95_low"
		o = append(o, 0xa9, 0x63, 0x69, 0x5f, 0x39, 0x35, 0x5f, 0x6c, 0x6f, 0x77)
		o = msgp.AppendFloat64(o, z.CI95Low)
		// string "ci_95_high"
		o = append(o, 0xaa, 0x63, 0x69, 0x5f, 0x39, 0x35, 0x5f, 0x68, 0x69, 0x67, 0x68)
		o = msgp.AppendFloat64(o, z.CI95High)
		// string "winning_hands"
		o = append(o, 0xad, 0x77, 0x69, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x73)
		o = msgp.AppendInt(o, z.WinningHands)
		// string "win_rate"
		o = append(o, 0xa8, 0x77, 0x69, 0x6e, 0x5f, 0x72, 0x61, 0x74, 0x65)
		o = msgp.AppendFloat64(o, z.WinRate)
		// string "showdown_wins"
		o = append(o, 0xad, 0x73, 0x68, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x77, 0x69, 0x6e, 0x73)
		o = msgp.AppendInt(o, z.ShowdownWins)
		// string "non_showdown_wins"
		o = append(o, 0xb1, 0x6e, 0x6f, 0x6e, 0x5f, 0x73, 0x68, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x77, 0x69, 0x6e, 0x73)
		o = msgp.AppendInt(o, z.NonShowdownWins)
		// string "showdown_win_rate"
		o = append(o, 0xb1, 0x73, 0x68, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x77, 0x69, 0x6e, 0x5f, 0x72, 0x61, 0x74, 0x65)
		o = msgp.AppendFloat64(o, z.ShowdownWinRate)
		// string "showdown_bb"
		o = append(o, 0xab, 0x73, 0x68, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x62, 0x62)
		o = msgp.AppendFloat64(o, z.ShowdownBB)
		// string "non_showdown_bb"
		o = append(o, 0xaf, 0x6e, 0x6f, 0x6e, 0x5f, 0x73, 0x68, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x62, 0x62)
		o = msgp.AppendFloat64(o, z.NonShowdownBB)
		// string "max_pot_bb"
		o = append(o, 0xaa, 0x6d, 0x61, 0x78, 0x5f, 0x70, 0x6f, 0x74, 0x5f, 0x62, 0x62)
		o = msgp.AppendFloat64(o, z.MaxPotBB)
		// string "big_pots"
		o = append(o, 0xa8, 0x62, 0x69, 0x67, 0x5f, 0x70, 0x6f, 0x74, 0x73)
		o = msgp.AppendInt(o, z.BigPots)
		// string "vpip"
		o = append(o, 0xa4, 0x76, 0x70, 0x69, 0x70)
		o = msgp.AppendFloat64(o, z.VPIP)
		// string "pfr"
		o = append(o, 0xa3, 0x70, 0x66, 0x72)
		o = msgp.AppendFloat64(o, z.PFR)
		// string "timeouts"
		o = append(o, 0xa8, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x73)
		o = msgp.AppendInt(o, z.Timeouts)
		// string "busts"
		o = append(o, 0xa5, 0x62, 0x75, 0x73, 0x74, 0x73)
		o = msgp.AppendInt(o, z.Busts)
		// string "responses_tracked"
		o = append(o, 0xb1, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x5f, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x64)
		o = msgp.AppendInt(o, z.ResponsesTracked)
		// string "avg_response_ms"
		o = append(o, 0xaf, 0x61, 0x76, 0x67, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x6d, 0x73)
		o = msgp.AppendFloat64(o, z.AvgResponseMs)
		// string "p95_response_ms"
		o = append(o, 0xaf, 0x70, 0x39, 0x35, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x6d, 0x73)
		o = msgp.AppendFloat64(o, z.P95ResponseMs)
		// string "max_response_ms"
		o = append(o, 0xaf, 0x6d, 0x61, 0x78, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x6d, 0x73)
		o = msgp.AppendFloat64(o, z.MaxResponseMs)
		// string "min_response_ms"
		o = append(o, 0xaf, 0x6d, 0x69, 0x6e, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x6d, 0x73)
		o = msgp.AppendFloat64(o, z.MinResponseMs)
		// string "response_std_ms"
		o = append(o, 0xaf, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x73, 0x74, 0x64, 0x5f, 0x6d, 0x73)
		o = msgp.AppendFloat64(o, z.ResponseStdMs)
		// string "response_timeouts"
		o = append(o, 0xb1, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x73)
		o = msgp.AppendInt(o, z.ResponseTimeouts)
		// string "response_disconnects"
		o = append(o, 0xb4, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x73)
		o = msgp.AppendInt(o, z.ResponseDisconnects)
		if (zb0001Mask & 0x20000000) == 0 { // if not omitted
			// string "position_stats"
			o = append(o, 0xae, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.PositionStats)))
			for za0001, za0002 := range z.PositionStats {
				o = msgp.AppendString(o, za0001)
				// map header, size 3
				// string "hands"
				o = append(o, 0x83, 0xa5, 0x68, 0x61, 0x6e, 0x64, 0x73)
				o = msgp.AppendInt(o, za0002.Hands)
				// string "net_bb"
				o = append(o, 0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
				o = msgp.AppendFloat64(o, za0002.NetBB)
				// string "bb_per_hand"
				o = append(o, 0xab, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
				o = msgp.AppendFloat64(o, za0002.BBPerHand)
			}
		}
		if (zb0001Mask & 0x40000000) == 0 { // if not omitted
			// string "street_stats"
			o = append(o, 0xac, 0x73, 0x74, 0x72, 0x65, 0x65, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.StreetStats)))
			for za0003, za0004 := range z.StreetStats {
				o = msgp.AppendString(o, za0003)
				// map header, size 3
				// string "hands_ended"
				o = append(o, 0x83, 0xab, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x5f, 0x65, 0x6e, 0x64, 0x65, 0x64)
				o = msgp.AppendInt(o, za0004.HandsEnded)
				// string "net_bb"
				o = append(o, 0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
				o = msgp.AppendFloat64(o, za0004.NetBB)
				// string "bb_per_hand"
				o = append(o, 0xab, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
				o = msgp.AppendFloat64(o, za0004.BBPerHand)
			}
		}
		if (zb0001Mask & 0x80000000) == 0 { // if not omitted
			// string "hand_category_stats"
			o = append(o, 0xb3, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.HandCategoryStats)))
			for za0005, za0006 := range z.HandCategoryStats {
				o = msgp.AppendString(o, za0005)
				// map header, size 3
				// string "hands"
				o = append(o, 0x83, 0xa5, 0x68, 0x61, 0x6e, 0x64, 0x73)
				o = msgp.AppendInt(o, za0006.Hands)
				// string "net_bb"
				o = append(o, 0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
				o = msgp.AppendFloat64(o, za0006.NetBB)
				// string "bb_per_hand"
				o = append(o, 0xab, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
				o = msgp.AppendFloat64(o, za0006.BBPerHand)
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PlayerDetailedStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "hands":
			z.Hands, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hands")
				return
			}
		case "net_bb":
			z.NetBB, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NetBB")
				return
			}
		case "bb_per_100":
			z.BB100, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BB100")
				return
			}
		case "mean":
			z.Mean, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mean")
				return
			}
		case "median":
			z.Median, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Median")
				return
			}
		case "std_dev":
			z.StdDev, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StdDev")
				return
			}
		case "ci_95_low":
			z.CI95Low, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CI95Low")
				return
			}
		case "ci_95_high":
			z.CI95High, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CI95High")
				return
			}
		case "winning_hands":
			z.WinningHands, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WinningHands")
				return
			}
		case "win_rate":
			z.WinRate, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WinRate")
				return
			}
		case "showdown_wins":
			z.ShowdownWins, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ShowdownWins")
				return
			}
		case "non_showdown_wins":
			z.NonShowdownWins, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NonShowdownWins")
				return
			}
		case "showdown_win_rate":
			z.ShowdownWinRate, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ShowdownWinRate")
				return
			}
		case "showdown_bb":
			z.ShowdownBB, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ShowdownBB")
				return
			}
		case "non_showdown_bb":
			z.NonShowdownBB, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NonShowdownBB")
				return
			}
		case "max_pot_bb":
			z.MaxPotBB, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxPotBB")
				return
			}
		case "big_pots":
			z.BigPots, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BigPots")
				return
			}
		case "vpip":
			z.VPIP, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VPIP")
				return
			}
		case "pfr":
			z.PFR, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PFR")
				return
			}
		case "timeouts":
			z.Timeouts, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timeouts")
				return
			}
		case "busts":
			z.Busts, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Busts")
				return
			}
		case "responses_tracked":
			z.ResponsesTracked, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResponsesTracked")
				return
			}
		case "avg_response_ms":
			z.AvgResponseMs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AvgResponseMs")
				return
			}
		case "p95_response_ms":
			z.P95ResponseMs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "P95ResponseMs")
				return
			}
		case "max_response_ms":
			z.MaxResponseMs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxResponseMs")
				return
			}
		case "min_response_ms":
			z.MinResponseMs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinResponseMs")
				return
			}
		case "response_std_ms":
			z.ResponseStdMs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResponseStdMs")
				return
			}
		case "response_timeouts":
			z.ResponseTimeouts, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResponseTimeouts")
				return
			}
		case "response_disconnects":
			z.ResponseDisconnects, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResponseDisconnects")
				return
			}
		case "position_stats":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PositionStats")
				return
			}
			if z.PositionStats == nil {
				z.PositionStats = make(map[string]PositionStatSummary, zb0002)
			} else if len(z.PositionStats) > 0 {
				clear(z.PositionStats)
			}
			for zb0002 > 0 {
				var za0002 PositionStatSummary
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PositionStats")
					return
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PositionStats", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "PositionStats", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "hands":
						za0002.Hands, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "PositionStats", za0001, "Hands")
							return
						}
					case "net_bb":
						za0002.NetBB, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "PositionStats", za0001, "NetBB")
							return
						}
					case "bb_per_hand":
						za0002.BBPerHand, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "PositionStats", za0001, "BBPerHand")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "PositionStats", za0001)
							return
						}
					}
				}
				z.PositionStats[za0001] = za0002
			}
		case "street_stats":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StreetStats")
				return
			}
			if z.StreetStats == nil {
				z.StreetStats = make(map[string]StreetStatSummary, zb0004)
			} else if len(z.StreetStats) > 0 {
				clear(z.StreetStats)
			}
			for zb0004 > 0 {
				var za0004 StreetStatSummary
				zb0004--
				var za0003 string
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StreetStats")
					return
				}
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StreetStats", za0003)
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "StreetStats", za0003)
						return
					}
					switch msgp.UnsafeString(field) {
					case "hands_ended":
						za0004.HandsEnded, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "StreetStats", za0003, "HandsEnded")
							return
						}
					case "net_bb":
						za0004.NetBB, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "StreetStats", za0003, "NetBB")
							return
						}
					case "bb_per_hand":
						za0004.BBPerHand, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "StreetStats", za0003, "BBPerHand")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "StreetStats", za0003)
							return
						}
					}
				}
				z.StreetStats[za0003] = za0004
			}
		case "hand_category_stats":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HandCategoryStats")
				return
			}
			if z.HandCategoryStats == nil {
				z.HandCategoryStats = make(map[string]CategoryStatSummary, zb0006)
			} else if len(z.HandCategoryStats) > 0 {
				clear(z.HandCategoryStats)
			}
			for zb0006 > 0 {
				var za0006 CategoryStatSummary
				zb0006--
				var za0005 string
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HandCategoryStats")
					return
				}
				var zb0007 uint32
				zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HandCategoryStats", za0005)
					return
				}
				for zb0007 > 0 {
					zb0007--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "HandCategoryStats", za0005)
						return
					}
					switch msgp.UnsafeString(field) {
					case "hands":
						za0006.Hands, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "HandCategoryStats", za0005, "Hands")
							return
						}
					case "net_bb":
						za0006.NetBB, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "HandCategoryStats", za0005, "NetBB")
							return
						}
					case "bb_per_hand":
						za0006.BBPerHand, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "HandCategoryStats", za0005, "BBPerHand")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "HandCategoryStats", za0005)
							return
						}
					}
				}
				z.HandCategoryStats[za0005] = za0006
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PlayerDetailedStats) Msgsize() (s int) {
	s = 3 + 6 + msgp.IntSize + 7 + msgp.Float64Size + 11 + msgp.Float64Size + 5 + msgp.Float64Size + 7 + msgp.Float64Size + 8 + msgp.Float64Size + 10 + msgp.Float64Size + 11 + msgp.Float64Size + 14 + msgp.IntSize + 9 + msgp.Float64Size + 14 + msgp.IntSize + 18 + msgp.IntSize + 18 + msgp.Float64Size + 12 + msgp.Float64Size + 16 + msgp.Float64Size + 11 + msgp.Float64Size + 9 + msgp.IntSize + 5 + msgp.Float64Size + 4 + msgp.Float64Size + 9 + msgp.IntSize + 6 + msgp.IntSize + 18 + msgp.IntSize + 16 + msgp.Float64Size + 16 + msgp.Float64Size + 16 + msgp.Float64Size + 16 + msgp.Float64Size + 16 + msgp.Float64Size + 18 + msgp.IntSize + 21 + msgp.IntSize + 15 + msgp.MapHeaderSize
	if z.PositionStats != nil {
		for za0001, za0002 := range z.PositionStats {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + 1 + 6 + msgp.IntSize + 7 + msgp.Float64Size + 12 + msgp.Float64Size
		}
	}
	s += 13 + msgp.MapHeaderSize
	if z.StreetStats != nil {
		for za0003, za0004 := range z.StreetStats {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + 1 + 12 + msgp.IntSize + 7 + msgp.Float64Size + 12 + msgp.Float64Size
		}
	}
	s += 20 + msgp.MapHeaderSize
	if z.HandCategoryStats != nil {
		for za0005, za0006 := range z.HandCategoryStats {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + 1 + 6 + msgp.IntSize + 7 + msgp.Float64Size + 12 + msgp.Float64Size
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PositionStatSummary) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "hands":
			z.Hands, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Hands")
				return
			}
		case "net_bb":
			z.NetBB, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "NetBB")
				return
			}
		case "bb_per_hand":
			z.BBPerHand, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BBPerHand")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z PositionStatSummary) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "hands"
	err = en.Append(0x83, 0xa5, 0x68, 0x61, 0x6e, 0x64, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Hands)
	if err != nil {
		err = msgp.WrapError(err, "Hands")
		return
	}
	// write "net_bb"
	err = en.Append(0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.NetBB)
	if err != nil {
		err = msgp.WrapError(err, "NetBB")
		return
	}
	// write "bb_per_hand"
	err = en.Append(0xab, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BBPerHand)
	if err != nil {
		err = msgp.WrapError(err, "BBPerHand")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PositionStatSummary) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "hands"
	o = append(o, 0x83, 0xa5, 0x68, 0x61, 0x6e, 0x64, 0x73)
	o = msgp.AppendInt(o, z.Hands)
	// string "net_bb"
	o = append(o, 0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
	o = msgp.AppendFloat64(o, z.NetBB)
	// string "bb_per_hand"
	o = append(o, 0xab, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
	o = msgp.AppendFloat64(o, z.BBPerHand)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PositionStatSummary) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "hands":
			z.Hands, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hands")
				return
			}
		case "net_bb":
			z.NetBB, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NetBB")
				return
			}
		case "bb_per_hand":
			z.BBPerHand, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BBPerHand")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PositionStatSummary) Msgsize() (s int) {
	s = 1 + 6 + msgp.IntSize + 7 + msgp.Float64Size + 12 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ShowdownHand) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "hole_cards":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "HoleCards")
				return
			}
			if cap(z.HoleCards) >= int(zb0002) {
				z.HoleCards = (z.HoleCards)[:zb0002]
			} else {
				z.HoleCards = make([]string, zb0002)
			}
			for za0001 := range z.HoleCards {
				z.HoleCards[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "HoleCards", za0001)
					return
				}
			}
		case "hand_rank":
			z.HandRank, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HandRank")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ShowdownHand) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "name"
	err = en.Append(0x83, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "hole_cards"
	err = en.Append(0xaa, 0x68, 0x6f, 0x6c, 0x65, 0x5f, 0x63, 0x61, 0x72, 0x64, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.HoleCards)))
	if err != nil {
		err = msgp.WrapError(err, "HoleCards")
		return
	}
	for za0001 := range z.HoleCards {
		err = en.WriteString(z.HoleCards[za0001])
		if err != nil {
			err = msgp.WrapError(err, "HoleCards", za0001)
			return
		}
	}
	// write "hand_rank"
	err = en.Append(0xa9, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x72, 0x61, 0x6e, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteString(z.HandRank)
	if err != nil {
		err = msgp.WrapError(err, "HandRank")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ShowdownHand) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "name"
	o = append(o, 0x83, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "hole_cards"
	o = append(o, 0xaa, 0x68, 0x6f, 0x6c, 0x65, 0x5f, 0x63, 0x61, 0x72, 0x64, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.HoleCards)))
	for za0001 := range z.HoleCards {
		o = msgp.AppendString(o, z.HoleCards[za0001])
	}
	// string "hand_rank"
	o = append(o, 0xa9, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x72, 0x61, 0x6e, 0x6b)
	o = msgp.AppendString(o, z.HandRank)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ShowdownHand) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "hole_cards":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HoleCards")
				return
			}
			if cap(z.HoleCards) >= int(zb0002) {
				z.HoleCards = (z.HoleCards)[:zb0002]
			} else {
				z.HoleCards = make([]string, zb0002)
			}
			for za0001 := range z.HoleCards {
				z.HoleCards[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HoleCards", za0001)
					return
				}
			}
		case "hand_rank":
			z.HandRank, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HandRank")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ShowdownHand) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 11 + msgp.ArrayHeaderSize
	for za0001 := range z.HoleCards {
		s += msgp.StringPrefixSize + len(z.HoleCards[za0001])
	}
	s += 10 + msgp.StringPrefixSize + len(z.HandRank)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *StreetChange) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "hand_id":
			z.HandID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HandID")
				return
			}
		case "street":
			z.Street, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Street")
				return
			}
		case "board":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Board")
				return
			}
			if cap(z.Board) >= int(zb0002) {
				z.Board = (z.Board)[:zb0002]
			} else {
				z.Board = make([]string, zb0002)
			}
			for za0001 := range z.Board {
				z.Board[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Board", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *StreetChange) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "type"
	err = en.Append(0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "hand_id"
	err = en.Append(0xa7, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.HandID)
	if err != nil {
		err = msgp.WrapError(err, "HandID")
		return
	}
	// write "street"
	err = en.Append(0xa6, 0x73, 0x74, 0x72, 0x65, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Street)
	if err != nil {
		err = msgp.WrapError(err, "Street")
		return
	}
	// write "board"
	err = en.Append(0xa5, 0x62, 0x6f, 0x61, 0x72, 0x64)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Board)))
	if err != nil {
		err = msgp.WrapError(err, "Board")
		return
	}
	for za0001 := range z.Board {
		err = en.WriteString(z.Board[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Board", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StreetChange) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "hand_id"
	o = append(o, 0xa7, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.HandID)
	// string "street"
	o = append(o, 0xa6, 0x73, 0x74, 0x72, 0x65, 0x65, 0x74)
	o = msgp.AppendString(o, z.Street)
	// string "board"
	o = append(o, 0xa5, 0x62, 0x6f, 0x61, 0x72, 0x64)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Board)))
	for za0001 := range z.Board {
		o = msgp.AppendString(o, z.Board[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StreetChange) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "hand_id":
			z.HandID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HandID")
				return
			}
		case "street":
			z.Street, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Street")
				return
			}
		case "board":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Board")
				return
			}
			if cap(z.Board) >= int(zb0002) {
				z.Board = (z.Board)[:zb0002]
			} else {
				z.Board = make([]string, zb0002)
			}
			for za0001 := range z.Board {
				z.Board[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Board", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StreetChange) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 8 + msgp.StringPrefixSize + len(z.HandID) + 7 + msgp.StringPrefixSize + len(z.Street) + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Board {
		s += msgp.StringPrefixSize + len(z.Board[za0001])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *StreetStatSummary) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "hands_ended":
			z.HandsEnded, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HandsEnded")
				return
			}
		case "net_bb":
			z.NetBB, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "NetBB")
				return
			}
		case "bb_per_hand":
			z.BBPerHand, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BBPerHand")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z StreetStatSummary) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "hands_ended"
	err = en.Append(0x83, 0xab, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x5f, 0x65, 0x6e, 0x64, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HandsEnded)
	if err != nil {
		err = msgp.WrapError(err, "HandsEnded")
		return
	}
	// write "net_bb"
	err = en.Append(0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.NetBB)
	if err != nil {
		err = msgp.WrapError(err, "NetBB")
		return
	}
	// write "bb_per_hand"
	err = en.Append(0xab, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BBPerHand)
	if err != nil {
		err = msgp.WrapError(err, "BBPerHand")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z StreetStatSummary) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "hands_ended"
	o = append(o, 0x83, 0xab, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x5f, 0x65, 0x6e, 0x64, 0x65, 0x64)
	o = msgp.AppendInt(o, z.HandsEnded)
	// string "net_bb"
	o = append(o, 0xa6, 0x6e, 0x65, 0x74, 0x5f, 0x62, 0x62)
	o = msgp.AppendFloat64(o, z.NetBB)
	// string "bb_per_hand"
	o = append(o, 0xab, 0x62, 0x62, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x68, 0x61, 0x6e, 0x64)
	o = msgp.AppendFloat64(o, z.BBPerHand)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StreetStatSummary) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "hands_ended":
			z.HandsEnded, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HandsEnded")
				return
			}
		case "net_bb":
			z.NetBB, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NetBB")
				return
			}
		case "bb_per_hand":
			z.BBPerHand, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BBPerHand")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z StreetStatSummary) Msgsize() (s int) {
	s = 1 + 12 + msgp.IntSize + 7 + msgp.Float64Size + 12 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Winner) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "amount":
			z.Amount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Amount")
				return
			}
		case "hole_cards":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "HoleCards")
				return
			}
			if cap(z.HoleCards) >= int(zb0002) {
				z.HoleCards = (z.HoleCards)[:zb0002]
			} else {
				z.HoleCards = make([]string, zb0002)
			}
			for za0001 := range z.HoleCards {
				z.HoleCards[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "HoleCards", za0001)
					return
				}
			}
		case "hand_rank":
			z.HandRank, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HandRank")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Winner) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	if z.HoleCards == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.HandRank == "" {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "name"
		err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Name)
		if err != nil {
			err = msgp.WrapError(err, "Name")
			return
		}
		// write "amount"
		err = en.Append(0xa6, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Amount)
		if err != nil {
			err = msgp.WrapError(err, "Amount")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "hole_cards"
			err = en.Append(0xaa, 0x68, 0x6f, 0x6c, 0x65, 0x5f, 0x63, 0x61, 0x72, 0x64, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.HoleCards)))
			if err != nil {
				err = msgp.WrapError(err, "HoleCards")
				return
			}
			for za0001 := range z.HoleCards {
				err = en.WriteString(z.HoleCards[za0001])
				if err != nil {
					err = msgp.WrapError(err, "HoleCards", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "hand_rank"
			err = en.Append(0xa9, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x72, 0x61, 0x6e, 0x6b)
			if err != nil {
				return
			}
			err = en.WriteString(z.HandRank)
			if err != nil {
				err = msgp.WrapError(err, "HandRank")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Winner) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	if z.HoleCards == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.HandRank == "" {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "name"
		o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Name)
		// string "amount"
		o = append(o, 0xa6, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt(o, z.Amount)
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "hole_cards"
			o = append(o, 0xaa, 0x68, 0x6f, 0x6c, 0x65, 0x5f, 0x63, 0x61, 0x72, 0x64, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.HoleCards)))
			for za0001 := range z.HoleCards {
				o = msgp.AppendString(o, z.HoleCards[za0001])
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "hand_rank"
			o = append(o, 0xa9, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x72, 0x61, 0x6e, 0x6b)
			o = msgp.AppendString(o, z.HandRank)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Winner) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "amount":
			z.Amount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Amount")
				return
			}
		case "hole_cards":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HoleCards")
				return
			}
			if cap(z.HoleCards) >= int(zb0002) {
				z.HoleCards = (z.HoleCards)[:zb0002]
			} else {
				z.HoleCards = make([]string, zb0002)
			}
			for za0001 := range z.HoleCards {
				z.HoleCards[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HoleCards", za0001)
					return
				}
			}
		case "hand_rank":
			z.HandRank, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HandRank")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Winner) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 7 + msgp.IntSize + 11 + msgp.ArrayHeaderSize
	for za0001 := range z.HoleCards {
		s += msgp.StringPrefixSize + len(z.HoleCards[za0001])
	}
	s += 10 + msgp.StringPrefixSize + len(z.HandRank)
	return
}
